<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FEDT</title>
  
  <subtitle>Front End Developer A-Ten&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://note.chenteng.me/"/>
  <updated>2017-12-04T16:24:29.199Z</updated>
  <id>http://note.chenteng.me/</id>
  
  <author>
    <name>A-Ten</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js 中的事件循环（Event loop）与异步</title>
    <link href="http://note.chenteng.me/2017/12/01/Node.js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://note.chenteng.me/2017/12/01/Node.js中的事件循环与异步/</id>
    <published>2017-12-01T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-js-中的事件循环（Event-loop）与异步"><a href="#Node-js-中的事件循环（Event-loop）与异步" class="headerlink" title="Node.js 中的事件循环（Event loop）与异步"></a>Node.js 中的事件循环（Event loop）与异步</h2><p>Node.js的特点是事件循环，其中不同的事件会分配到不同的事件观察者身上，比如idle观察者，定时器观察者，I/O观察者等等，事件循环每次循环称为一次Tick，每次Tick按照先后顺序从事件观察者中取出事件进行处理。</p><p>下图是Node.js v0.9版本的事件循环示意图：<br><img src="https://fedt-blog.b0.upaiyun.com/article_img/node-event-loop.jpg" alt="Node.js v0.9版本的事件循环示意图">  </p><p><strong>当Node.js启动时会初始化event loop, 每一个event loop都会包含按如下顺序六个循环阶段，</strong>  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   +-----------------------+</span><br><span class="line">+-&gt;+        timers         |</span><br><span class="line">|  +-----------------------+</span><br><span class="line">|  +-----------------------+</span><br><span class="line">|  |     I/O callbacks     |</span><br><span class="line">|  +-----------------------+</span><br><span class="line">|  +-----------------------+</span><br><span class="line">|  |     idle, prepare     |</span><br><span class="line">|  +-----------------------+      +---------------+</span><br><span class="line">|  +-----------------------+      |   incoming:   |</span><br><span class="line">|  |         poll          +&lt;-----+  connections, |</span><br><span class="line">|  +-----------------------+      |   data, etc.  |</span><br><span class="line">|  +-----------------------+      +---------------+</span><br><span class="line">|  |        check          |</span><br><span class="line">|  +-----------------------+</span><br><span class="line">|  +-----------------------+</span><br><span class="line">+--+    close callbacks    |</span><br><span class="line">   +-----------------------+</span><br></pre></td></tr></table></figure><ul><li>timers 阶段: 这个阶段执行setTimeout(callback) and setInterval(callback)预定的callback;</li><li>I/O callbacks 阶段: 执行除了 close事件的callbacks、被timers(定时器，setTimeout、setInterval等)设定的callbacks、setImmediate()设定的- callbacks之外的callbacks;</li><li>idle, prepare 阶段: 仅node内部使用;</li><li>poll 阶段: 获取新的I/O事件, 适当的条件下node将阻塞在这里;</li><li>check 阶段: 执行setImmediate() 设定的callbacks;</li><li>close callbacks 阶段: 比如socket.on(‘close’, callback)的callback会在这个阶段执行.</li></ul><p>每一个阶段都有一个装有callbacks的fifo queue(队列)，当event loop运行到一个指定阶段时，<br>node将执行该阶段的fifo queue(队列)，当队列callback执行完或者执行callbacks数量超过该阶段的上限时，<br>event loop会转入下一下阶段.</p><blockquote><p>注意上面六个阶段都不包括 process.nextTick()</p></blockquote><h3 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a>poll阶段</h3><p>poll阶段是衔接整个event loop各个阶段比较重要的阶段，<strong>在node.js里，任何异步方法（除timer,close,setImmediate之外）完成时，都会将其callback加到poll queue里,并立即执行。</strong><br>poll 阶段有两个主要的功能：  </p><ul><li>处理poll队列（poll queue）的事件(callback);</li><li>执行timers的callback,当到达timers指定的时间时;</li></ul><p><strong>如果event loop进入了 poll阶段，且代码未设定timer，将会发生下面情况：</strong></p><ul><li>如果poll queue不为空，event loop将同步的执行queue里的callback,直至queue为空，或执行的callback到达系统上限;</li><li>如果poll queue为空，将会发生下面情况：<ul><li>如果代码已经被setImmediate()设定了callback, event loop将结束poll阶段进入check阶段，并执行check阶段的queue (check阶段的queue是 setImmediate设定的)</li><li>如果代码没有设定setImmediate(callback)，event loop将阻塞在该阶段等待callbacks加入poll queue;</li></ul></li></ul><p><strong>如果event loop进入了 poll阶段，且代码设定了timer：</strong></p><ul><li>如果poll queue进入空状态时（即poll 阶段为空闲状态），event loop将检查timers,如果有1个或多个timers时间时间已经到达，event loop将按循环顺序进入 timers 阶段，并执行timer queue.</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="comment">// 花费9毫秒</span></span><br><span class="line">  fs.readFile(<span class="string">'/path/to/xxxx.pdf'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">var</span> fileReadTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line">&#125;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">someAsyncOperation(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  fileReadtime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">Date</span>.now() - fileReadtime &lt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout: '</span> + (delay) + <span class="string">"ms have passed since I was scheduled"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fileReaderTime'</span>,fileReadtime - timeoutScheduled);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果：setTimeout callback先执行，someAsyncOperation callback后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; node eventloop.js</span><br><span class="line">setTimeout: 7ms have passed since I was scheduled</span><br><span class="line">fileReaderTime 9</span><br></pre></td></tr></table></figure></p><p>解释：<br>当时程序启动时，event loop初始化：</p><ol><li>timer阶段（无callback到达，setTimeout需要10毫秒）</li><li>i/o callback阶段，无异步i/o完成</li><li>忽略</li><li>poll阶段，阻塞在这里，当运行5ms时，poll依然空闲，但已设定timer,且时间已到达，因此，event loop需要循环到timer阶段,执行setTimeout callback,1 由于从poll –&gt; timer中间要经历check,close阶段,这些阶段也会消耗一定时间，因此执行setTimeout callback实际是7毫秒 然后又回到poll阶段等待异步1 i/o完成，在9毫秒时fs.readFile完成，其callback加入poll queue并执行。</li></ol><h3 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a><code>setTimeout</code> 和 <code>setImmediate</code></h3><p>二者非常相似，但是二者区别取决于他们什么时候被调用.</p><ul><li>setImmediate 设计在poll阶段完成时执行，即check阶段；</li><li>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行；但其在timer阶段执行</li></ul><p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure></p><p>理解了event loop的各阶段顺序这个例子很好理解：<br>因为fs.readFile callback执行完后，程序设定了timer 和 setImmediate，因此poll阶段不会被阻塞进而进入check阶段先执行setImmediate，后进入timer阶段执行setTimeout</p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h3><p><strong>process.nextTick()不在event loop的任何阶段执行，而是在各个阶段切换的中间执行,即从一个阶段切换到下个阶段前执行。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'nextTick3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick2'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">-&gt; node eventloop.js</span></span><br><span class="line"><span class="comment">nextTick1</span></span><br><span class="line"><span class="comment">nextTick2</span></span><br><span class="line"><span class="comment">setImmediate</span></span><br><span class="line"><span class="comment">nextTick3</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>从poll —&gt; check阶段，先执行process.nextTick，<br>nextTick1<br>nextTick2<br>然后进入check,setImmediate，<br>setImmediate<br>执行完setImmediate后，出check,进入close callback前，执行process.nextTick<br>nextTick3<br>最后进入timer执行setTimeout<br>setTimeout  </p><p>process.nextTick()是node早期版本无setImmediate时的产物，node作者推荐我们尽量使用setImmediate。</p><h3 id="事件循环与Promise"><a href="#事件循环与Promise" class="headerlink" title="事件循环与Promise"></a>事件循环与<code>Promise</code></h3><p>直接看例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。  </p><p>然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。  </p><p>然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。   </p><p>因此，应当先输出 5，然后再输出 4 。  </p><p>最后在到下一个 tick，就是 1 。  </p><p>结果： 依次输出 2 3 5 4 1</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">Node.js Event Loop 的理解 Timers，process.nextTick()</a></li><li><a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">Excuse me？这个前端面试在搞事！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Node-js-中的事件循环（Event-loop）与异步&quot;&gt;&lt;a href=&quot;#Node-js-中的事件循环（Event-loop）与异步&quot; class=&quot;headerlink&quot; title=&quot;Node.js 中的事件循环（Event loop）与异步&quot;&gt;&lt;/a&gt;Node.js 中的事件循环（Event loop）与异步&lt;/h2&gt;&lt;p&gt;Node.js的特点是事件循环，其中不同的事件会分配到不同的事件观察者身上，比如idle观察者，定时器观察者，I/O观察者等等，事件循环每次循环称为一次Tick，每次Tick按照先后顺序从事件观察者中取出事件进行处理。&lt;/p&gt;
&lt;p&gt;下图是Node.js v0.9版本的事件循环示意图：&lt;br&gt;&lt;img src=&quot;https://fedt-blog.b0.upaiyun.com/article_img/node-event-loop.jpg&quot; alt=&quot;Node.js v0.9版本的事件循环示意图&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当Node.js启动时会初始化event loop, 每一个event loop都会包含按如下顺序六个循环阶段，&lt;/strong&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Node.js" scheme="http://note.chenteng.me/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化与反柯里化</title>
    <link href="http://note.chenteng.me/2017/03/18/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E5%8F%8D%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://note.chenteng.me/2017/03/18/函数柯里化与反柯里化/</id>
    <published>2017-03-18T01:01:27.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程近期再度被热炒，各社区对函数式编程的讲解和推崇也是层出不穷。好像要是不知道函数式编程，就没法跟大佬们愉快的玩耍了。<br>这一高大上的概念听起来似乎非常晦涩难懂让人摸不到头脑，然而实际上，也确实如此……<br>本文记录对函数式编程密切相关的两个概念：柯里化与反柯里化的个人理解。</p><h3 id="从函数式编程说起"><a href="#从函数式编程说起" class="headerlink" title="从函数式编程说起"></a>从函数式编程说起</h3><p>函数式编程有被称为函数范式，是一种编程范式，一种编程思想。<br>函数式的核心思想就是通过“纯函数”进行过程抽象，使代码逻辑清晰、降低耦合、便于维护。<br>这里出现了一个新概念：“纯函数”。纯函数即无状态、无副作用、幂等、无关时序的函数，指的是函数的输出完全由输入所决定，运行过程不依赖于系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。<br>而本文要说的柯里化(currying)与反柯里(uncurrying)化有什么关系呢？<br>柯里化和反柯里化是函数式编程的一个特性，是函数提纯的一种手段。<br><a id="more"></a></p><h3 id="柯里化-currying"><a href="#柯里化-currying" class="headerlink" title="柯里化(currying)"></a>柯里化(currying)</h3><p>柯里化又称<em>部分求值</em>，维基百科上的定义：</p><blockquote><p>是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数并且返回结果的新函数的技术。 </p></blockquote><p>通俗来说就是不会立刻求值，而是到了需要的时候再去求值。<br>柯里化有3个常见作用：</p><ol><li>参数复用</li><li>提前返回</li><li>延迟计算/运行<h4 id="柯里化函数创建的步骤"><a href="#柯里化函数创建的步骤" class="headerlink" title="柯里化函数创建的步骤"></a>柯里化函数创建的步骤</h4></li></ol><p>柯里化函数一般由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。<br>下面是创建柯里化函数的通用方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自《JavaScript高级程序设计》22.1.5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs)</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, finalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curriedAdd = curry(add, <span class="number">5</span>)</span><br><span class="line">alert(curridAdd(<span class="number">3</span>)) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></p><p>以上函数就是一个简单的柯里化函数，被柯里化的函数只需传入部分值即可，因为部分参数已经保存在了柯里化函数返回的闭包中。</p><h4 id="一个通用的柯里化函数实现："><a href="#一个通用的柯里化函数实现：" class="headerlink" title="一个通用的柯里化函数实现："></a>一个通用的柯里化函数实现：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> _fn(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 如果没有传入参数就开始求值，</span></span><br><span class="line">     <span class="comment">// 否则将参数放入闭包_args中，并继续curring</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [].push.apply(_args, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> _fn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">var</span> plus = curry(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br><span class="line">plus(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)() <span class="comment">// 等价于plus(1, 2)(3, 4)() //10</span></span><br></pre></td></tr></table></figure><p>以上函数是更为通用的柯里化函数。原理还是一样不断的往闭包中的<code>_args</code>数组中存放参数，。不同的是只要是传参调用<code>curried</code>函数，则返回函数本身用于下次继续调用，只在不传参的时候，才真正调用原函数并传递闭包中保存的所有参数（<code>_args</code>）。</p><h3 id="反柯里化-uncurrying"><a href="#反柯里化-uncurrying" class="headerlink" title="反柯里化(uncurrying)"></a>反柯里化(uncurrying)</h3><p>柯里化(<code>currying</code>)是预先填入一些参数，目的是为了固定参数, 延迟计算等<br>反柯里化(<code>uncurrying</code>)就是把原来已经固定的参数或者this上下文等当作参数延迟到未来传递。  </p><h4 id="反柯里化的三种实现"><a href="#反柯里化的三种实现" class="headerlink" title="反柯里化的三种实现"></a>反柯里化的三种实现</h4><p>反柯里化函数有三种实现，其中两种大同小异。  </p><h4 id="第一种实现方法："><a href="#第一种实现方法：" class="headerlink" title="第一种实现方法："></a>第一种实现方法：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为反柯里化只针对函数，所以直接将uncurrying放到Function原型对象上</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(_that, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码做了3件事：</p><ul><li>在<code>Function</code>原型上增加<code>uncurrying</code>方法，方便所有函数继承</li><li>返回函数，即暴露方法对外的接口</li><li>使用<code>call</code>将调用对象设置为原函数，并用<code>apply</code>将参数传入其中</li></ul><h4 id="第二种实现："><a href="#第二种实现：" class="headerlink" title="第二种实现："></a>第二种实现：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _that.apply(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式同上一种差不多，相比之下这种容易理解一点。<br>闭包中的<code>_taht</code>仍是原函数，返回的函数调用时直接利用<code>_that.apply</code>方法将调用时执行上下文换为传入的第一个参数。<br>结合一个例子看下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.uncurrying() <span class="comment">// 被反柯里化的函数是数组的push方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="comment">// boj是一个类数组对象</span></span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">push(obj, <span class="number">2</span>) <span class="comment">// &#123;0: 1, 1: 2, length: 2&#125;</span></span><br></pre></td></tr></table></figure></p><p>可以看到本无<code>push</code>方法的<code>obj</code>对象被传入反柯里化的push方法中，成功的使用了数组的<code>push</code>方法<br>以上两种实现方法的核心是使用<code>call</code>或者<code>apply</code>来切换原函数调用时的上下文，使原函数能应用于原本没有该方法的对象。  </p><h4 id="第三种实现方法"><a href="#第三种实现方法" class="headerlink" title="第三种实现方法"></a>第三种实现方法</h4><p>前两种实现都是借助<code>call</code>或<code>apply</code>来在调用过程中切换函数执行上下文实现。而在<code>ES5</code>中，提供了<code>bind</code>方法原生实现绑定执行上下文。<br>用<code>bind</code>实现反柯里化代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.call.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bind</code>返回一个已经绑定了执行上下文的函数<br>假设函数<code>fn</code>调用了<code>uncurrying</code>方法，将返回一个如下方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.call.apply(fn, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见效果是同第一种实现一样的。</p><h4 id="反柯里化的例子"><a href="#反柯里化的例子" class="headerlink" title="反柯里化的例子"></a>反柯里化的例子</h4><p>前面已经有了一个<code>push</code>方法的例子，这里看看其他运用<code>uncurrying</code>的例子。<br>例一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uncurrying的使用</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayName = person1.sayName.uncurrying()</span><br><span class="line">sayName(person2) <span class="comment">// 'Tom'</span></span><br></pre></td></tr></table></figure></p><p>例二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反柯里化自身</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> uncurrying = <span class="built_in">Function</span>.prototype.uncurrying.uncurrying()</span><br><span class="line"><span class="keyword">var</span> sayName = uncurrying(person1.sayName)</span><br><span class="line">sayName(person2) <span class="comment">// 'Tom'</span></span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>柯里化和反柯里化作为函数范式的特征，都是很好的利用了高阶函数。引用一段我认为对柯里、反柯里化很好的理解：  </p><blockquote><p>柯里化体现的思想是”归一”, 多个参数化为一个参数, 然后逐个处理, 便于产生偏函数, 实现链式调用;<br>反柯里化体现的思想是”延伸”, 通过拓展方法的作用域, 使得它变得更通用, 提高了代码的复用性. 它们都提升了代码的优雅性.</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.h5jun.com/post/pure-function.html" target="_blank" rel="noopener">JavaScript 中的“纯函数”</a></li><li><a href="https://www.h5jun.com/post/higher-order-function-play-with-pure-function.html" target="_blank" rel="noopener">高阶函数对系统的“提纯”</a></li><li><a href="https://rockjins.js.org/2017/02/15/curring-uncurring/" target="_blank" rel="noopener">简单理解JavaScript中的柯里化和反柯里化</a></li><li><a href="http://www.alloyteam.com/2013/08/javascript-zhong-you-qu-di-fan-ke-li-hua-ji-shu/#prettyPhoto" target="_blank" rel="noopener">Javascript中有趣的反柯里化技术</a></li><li><a href="http://louiszhai.github.io/2015/12/16/currying/" target="_blank" rel="noopener">函数式编程之柯里化与反柯里化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程近期再度被热炒，各社区对函数式编程的讲解和推崇也是层出不穷。好像要是不知道函数式编程，就没法跟大佬们愉快的玩耍了。&lt;br&gt;这一高大上的概念听起来似乎非常晦涩难懂让人摸不到头脑，然而实际上，也确实如此……&lt;br&gt;本文记录对函数式编程密切相关的两个概念：柯里化与反柯里化的个人理解。&lt;/p&gt;
&lt;h3 id=&quot;从函数式编程说起&quot;&gt;&lt;a href=&quot;#从函数式编程说起&quot; class=&quot;headerlink&quot; title=&quot;从函数式编程说起&quot;&gt;&lt;/a&gt;从函数式编程说起&lt;/h3&gt;&lt;p&gt;函数式编程有被称为函数范式，是一种编程范式，一种编程思想。&lt;br&gt;函数式的核心思想就是通过“纯函数”进行过程抽象，使代码逻辑清晰、降低耦合、便于维护。&lt;br&gt;这里出现了一个新概念：“纯函数”。纯函数即无状态、无副作用、幂等、无关时序的函数，指的是函数的输出完全由输入所决定，运行过程不依赖于系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。&lt;br&gt;而本文要说的柯里化(currying)与反柯里(uncurrying)化有什么关系呢？&lt;br&gt;柯里化和反柯里化是函数式编程的一个特性，是函数提纯的一种手段。&lt;br&gt;
    
    </summary>
    
      <category term="技术分享" scheme="http://note.chenteng.me/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://note.chenteng.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数节流(Throttling)和函数防抖(Debouncing)</title>
    <link href="http://note.chenteng.me/2017/02/26/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/"/>
    <id>http://note.chenteng.me/2017/02/26/函数节流和函数防抖/</id>
    <published>2017-02-26T22:09:48.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数节流-Throttling-和函数防抖-Debouncing"><a href="#函数节流-Throttling-和函数防抖-Debouncing" class="headerlink" title="函数节流(Throttling)和函数防抖(Debouncing)"></a>函数节流(Throttling)和函数防抖(Debouncing)</h2><p>函数节流和函数防抖是平时组做也页面性能优化的两种重要技巧。他们在各类需要频繁触发的工作场景中，<br>比如对页面<code>onscroll</code>和<code>onresize</code>事件的监听，解决由于这种频繁触发的高消耗操作会带来<br>性能问题。</p><p>平时在应用中，使用较多的也广为人知的是函数节流(throtting),相对来说函数防抖(debouncing)<br>使用得较少，两个的区别也很模糊，这篇主要从具体实现上区分throttle和debounce。<br><a id="more"></a></p><h3 id="函数节流-throttling"><a href="#函数节流-throttling" class="headerlink" title="函数节流(throttling)"></a>函数节流(throttling)</h3><p>首先来看函数节流。函数节流的作用是，不论触发频率，单位时间内指定函数只被调用一次。就像涓涓细流一样<br>平缓。<br>具体代码实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* - 节流函数</span></span><br><span class="line"><span class="comment">* @param &#123;Function&#125; fn - 要执行的函数</span></span><br><span class="line"><span class="comment">* @param &#123;Number&#125; interval - 延迟执行的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> firstTime = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>    </span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123; <span class="comment">// 第一次则立即执行</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123; <span class="comment">// 上次延迟操作还未被执行</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 延迟执行</span></span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">    &#125;, interval || <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用<code>ES6</code>语法来简化<code>Throtting</code>函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="keyword">var</span> firstTime</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> timer = <span class="literal">null</span>, interval) <span class="comment">// 固定时间清除定时器id</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args) <span class="comment">// 不在定时器回调里调用故不用指定this(此处也可以按照上面思路在回调中调用，箭头函数自动绑定this)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数防抖-Debouncing"><a href="#函数防抖-Debouncing" class="headerlink" title="函数防抖(Debouncing)"></a>函数防抖(Debouncing)</h3><p>相对于函数节流，函数防抖是等待事件触发之后等一段时间在执行，如果触发频率高于设定的延迟时间，则一直等下下去<br>看到一个形象的比喻就是乘坐电梯的时候，如果电梯关闭时间是10s，这10s时间内有人进出电梯那么<br>电梯就会再等10s知道10s之内无人出入才会关门<br>防抖函数实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* - 防抖函数</span></span><br><span class="line"><span class="comment">* @param &#123;Function&#125; fn - 要执行的函数</span></span><br><span class="line"><span class="comment">* @param &#123;Number&#125; interval - 延迟执行的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="keyword">var</span> firstTime = <span class="literal">true</span>  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer) <span class="comment">// 每次触发都先清除定时器是之处于等待状态</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">      firstTime = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">    &#125;, interval || <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，使用<code>ES6</code>语法可以简化代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, interval = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="keyword">var</span> firstTime = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">      firstTime = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> fn.apply(<span class="keyword">this</span>, args), interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数节流和函数防抖功能相似，却有着不同的使用场景。根据需求合理使用会获得很大得性能提升，在平时项目中应该根据应用场景<br>多多使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数节流-Throttling-和函数防抖-Debouncing&quot;&gt;&lt;a href=&quot;#函数节流-Throttling-和函数防抖-Debouncing&quot; class=&quot;headerlink&quot; title=&quot;函数节流(Throttling)和函数防抖(Debouncing)&quot;&gt;&lt;/a&gt;函数节流(Throttling)和函数防抖(Debouncing)&lt;/h2&gt;&lt;p&gt;函数节流和函数防抖是平时组做也页面性能优化的两种重要技巧。他们在各类需要频繁触发的工作场景中，&lt;br&gt;比如对页面&lt;code&gt;onscroll&lt;/code&gt;和&lt;code&gt;onresize&lt;/code&gt;事件的监听，解决由于这种频繁触发的高消耗操作会带来&lt;br&gt;性能问题。&lt;/p&gt;
&lt;p&gt;平时在应用中，使用较多的也广为人知的是函数节流(throtting),相对来说函数防抖(debouncing)&lt;br&gt;使用得较少，两个的区别也很模糊，这篇主要从具体实现上区分throttle和debounce。&lt;br&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="原生JS" scheme="http://note.chenteng.me/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>层叠上下文与z-index</title>
    <link href="http://note.chenteng.me/2017/02/23/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8Ez-index/"/>
    <id>http://note.chenteng.me/2017/02/23/层叠上下文与z-index/</id>
    <published>2017-02-23T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<p>最近在博客文章页面加上了一个阅读进度条，功能实现起来很简单，监听<code>scroll</code>事件改bar的宽度，点击bar滚动到相应位置。<br>但是这期间遇到一个小问题，小屏下，原来的菜单栏覆盖了我新加的进度条。<br>我一看，两个都是<code>fixed</code>定位，凭直觉应该是我的进度条<code>z-index</code>设置不够大。自信加大<code>z-index</code>之后，发现<br>并没有变成我想要效果。<br>经过我一系列的翻查资料并用代码还原场景测试，基本确定这是<code>Chrome</code>浏览器的<code>bug</code>。<br>不过这是后事，这篇主要记录总结与此相关的知识点。<br><a id="more"></a></p><h3 id="从问题开始"><a href="#从问题开始" class="headerlink" title="从问题开始"></a>从问题开始</h3><p>以下代码能基本还原我遇到的问题<br>HTML代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span> <span class="attr">class</span>=<span class="string">"fadeIn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div2-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fadeIn</span> &#123;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;      </span><br><span class="line">  <span class="attribute">animation-name</span>: fadeIn;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> fadeIn &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我博客中现象为红色<code>#div1</code>覆盖在黄色<code>#div2-1</code>之上，而上面的<code>demo</code>最终效果相反。</p><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>由现象看本质，先来梳理相关知识点。</p><ol><li>概念<br>我们将一张网页看做是一个三维结构，页面中的元素延屏幕向用户（z轴）的一个立体空间上堆叠，<br>如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。<blockquote><p>与此相关的还有一个抽象概念：<strong>层叠水平</strong>。层叠水平（stacking level）决定了同一个层叠上下文中元素在z轴上的显示顺序。<br>   有一个特性是： 普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在<strong>当前</strong>层叠上下文元素中才有意义。</p></blockquote></li><li>层叠上下文特性<ul><li>层叠上下文的层叠水平要比普通元素高；</li><li>层叠上下文可以阻断元素的混合模式(<code>mix-blend-mode</code>)；</li><li>层叠上下文可以<strong>嵌套</strong>，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在<strong>父</strong>层叠上下文的层叠顺序中。</li></ul></li><li>层叠上下文的创建(重点)<ul><li>页面根元素天生具有层叠上下文，称之为“根层叠上下文”</li><li>z-index值为数值的<strong>定位</strong>元素的传统层叠上下文(必须是定位：<code>position</code>不为<code>auto</code>)</li><li>其他CSS3属性<ul><li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li><li>元素的<code>opacity</code>值不是1.</li><li>元素的<code>transform</code>值不是<code>none</code>.</li><li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li><li>元素的<code>filter</code>值不是<code>none</code>.</li><li>元素的<code>isolation</code>值是<code>isolate</code>.</li><li><code>will-change</code>指定的属性值为上面任意一个。</li><li>元素的<code>-webkit-overflow-scrollin</code>g设为<code>touch</code>.</li></ul></li></ul></li></ol><h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><ol><li>概念<br>层叠顺序表示元素发生层叠时候有着特定的垂直显示顺序规则。<br>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img src="http://olxg48efw.bkt.clouddn.com/article_img/stacking-order.png" alt="层叠顺序规则"></li><li>层叠准则<ol><li>谁大谁上：当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li><li>后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol></li></ol><h3 id="回到问题上"><a href="#回到问题上" class="headerlink" title="回到问题上"></a>回到问题上</h3><p>根据以上关于层叠上下文、层叠顺序的知识，大概可以看出问题所在。<br><code>#div1</code>是<code>z-index</code>值为数值的元素，所以有独立的层叠上下文，<code>#div2-1</code>也是如此。<br>关键是<code>#div2</code>！它是定位元素(<code>position: relative</code>)，但它没有数值<code>z-index</code>，所以它没有创建独立的层叠上下文…吗？<br>如果<code>#div2</code>并没有独立的层叠上下文，那么<code>#div1</code>和<code>#div2-1</code>处于同一父层叠上下文(根层叠上下文<code>html</code>元素)中<br>遵循“谁大谁上”的层叠准则那么<code>#div2-1</code>应该应该在<code>#div1</code>之上显示。<br>实际上并没有这么简单。<code>#div2</code>上有一个<code>fadeIn</code>的过度动画。<code>fadeIn</code>过渡动画是通过改变元素的<code>opacity</code>属性来实现。<br>所以动画执行完之前，<code>#div2</code>通过“不为0的<code>opacity</code>”这种方式创建了执行上下文。这期间<code>#div1</code>与<code>#div2-1</code>不再处于同一个父层叠上下文。<br>根据层叠上下文“嵌套”的特性，此时的<code>#div2-1</code>的层叠水平受限于其父层叠上下文<code>#div2</code>，<code>#div1</code>与<code>#div2</code>处同一级，而<code>#div1</code>层叠水平大于<code>#div1</code><br>（根据层叠规则），因此<code>#div1</code>显示在<code>#div2-1</code>之上，等待过渡动画执行完<code>#div2</code>再次失去独立的层叠上下文，从而恢复之前的状态。<br>观察最开始的demo也是这样这样的实际效果。但是我博客中的实际代码却不这样，左侧的navbar一直在进度条之上，而当我打开<br>控制台，手动移除进度条容器元素上的<code>fadeIn</code>类时才正常显示。因此我认为这是一个bug。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾整个过程，我从一开始认定是<code>z-index</code>的值大小导致的问题，修改之后发现并没有生效。这就暴露了自己最相关知识点的不熟悉，只是知道皮毛<br>不知其所以然。经过一系列的验证与探究，发现平时经常用的一条<code>z-index</code>背后竟然有如此多的规则细节，让我感叹就算是最基本的<code>CSS</code>知识<br>我还是存在欠缺。以后的工作与学习过程中，一定要多实践，多钻研，扫除知识盲区，特别是经常用到的，并多记录总结，以提高自己专业水准。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解CSS中的层叠上下文和层叠顺序</a></li><li><a href="http://www.jianshu.com/p/d5cc3e1e432c" target="_blank" rel="noopener">z-index层叠上下文</a></li><li><a href="http://www.cnblogs.com/elcarim5efil/p/4764607.html" target="_blank" rel="noopener">层叠上下文 Stacking Context</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在博客文章页面加上了一个阅读进度条，功能实现起来很简单，监听&lt;code&gt;scroll&lt;/code&gt;事件改bar的宽度，点击bar滚动到相应位置。&lt;br&gt;但是这期间遇到一个小问题，小屏下，原来的菜单栏覆盖了我新加的进度条。&lt;br&gt;我一看，两个都是&lt;code&gt;fixed&lt;/code&gt;定位，凭直觉应该是我的进度条&lt;code&gt;z-index&lt;/code&gt;设置不够大。自信加大&lt;code&gt;z-index&lt;/code&gt;之后，发现&lt;br&gt;并没有变成我想要效果。&lt;br&gt;经过我一系列的翻查资料并用代码还原场景测试，基本确定这是&lt;code&gt;Chrome&lt;/code&gt;浏览器的&lt;code&gt;bug&lt;/code&gt;。&lt;br&gt;不过这是后事，这篇主要记录总结与此相关的知识点。&lt;br&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="CSS" scheme="http://note.chenteng.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Git工具学习笔记</title>
    <link href="http://note.chenteng.me/2016/12/02/LearnGitTool/"/>
    <id>http://note.chenteng.me/2016/12/02/LearnGitTool/</id>
    <published>2016-12-02T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note-for-learn-git-tool"><a href="#Note-for-learn-git-tool" class="headerlink" title="Note for learn git tool"></a>Note for learn git tool</h2><blockquote><p>2016/12/2<br>Chuck</p></blockquote><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li>创建SSH key <code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li><li>要关联一个远程库，使用命令 <code>git remote add origin git@server-name:path/repo-name.git</code><ol><li>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 <code>master</code> 分支的所有内容</li><li>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改</li></ol></li></ul><a id="more"></a><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li><p>创建并切换分支</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure><p>  等同于以下两行命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure></li><li><p>在dev branch上提交</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br></pre></td></tr></table></figure></li><li><p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></li><li><p>切换到<code>master</code>分支后，合并<code>dev</code>分支到<code>master</code>分支</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure></li><li><p>合并完成后，就可以放心地删除dev分支了：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure></li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>合并不同分支可能会产生冲突，比如修改了同一行内容</li></ul><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><ul><li><p>首先，仍然创建并切换dev分支：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></li><li><p>修改readme.txt文件，并提交一个新的commit：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"add merge"</span></span><br><span class="line">[dev 6224937] add merge</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></li><li><p>现在，我们切换回master：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure></li><li><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line">readme.txt |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><blockquote><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p></blockquote></li><li>合并后，我们用git log看看分支历史：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   7825a50 merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 6224937 add merge</span><br><span class="line">|/</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><ul><li><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 6224937 add merge</span><br><span class="line">HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure></li><li><p>stash之后，可以checkout到其他分支处理bug，处理完bug切到当前分支，<code>git stash pop</code>回到工作现场</p></li></ul><h3 id="删除未经合并的分支"><a href="#删除未经合并的分支" class="headerlink" title="删除未经合并的分支"></a>删除未经合并的分支</h3><ul><li><p>删除未经合并的分支，会提示删除失败</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-v</span><br><span class="line">error: The branch <span class="string">'feature-v'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D feature-v'</span>.</span><br></pre></td></tr></table></figure><p>  此时需要使用<code>git branch -D feature-v</code>来强制删除</p></li></ul><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul><li><p>多人协作的工作模式通常是这样：</p><ul><li><p>首先，可以试图用 <code>git push origin branch-name</code> 推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用 <code>git pull</code> 试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用 <code>git push origin branch-name</code> 推送就能成功！</p></li><li><p>如果 <code>git pull</code> 提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream branch-name origin/branch-name</code> 。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Note-for-learn-git-tool&quot;&gt;&lt;a href=&quot;#Note-for-learn-git-tool&quot; class=&quot;headerlink&quot; title=&quot;Note for learn git tool&quot;&gt;&lt;/a&gt;Note for learn git tool&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2016/12/2&lt;br&gt;Chuck&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建SSH key &lt;code&gt;$ ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;要关联一个远程库，使用命令 &lt;code&gt;git remote add origin git@server-name:path/repo-name.git&lt;/code&gt;&lt;ol&gt;
&lt;li&gt;关联后，使用命令 &lt;code&gt;git push -u origin master&lt;/code&gt; 第一次推送 &lt;code&gt;master&lt;/code&gt; 分支的所有内容&lt;/li&gt;
&lt;li&gt;此后，每次本地提交后，只要有必要，就可以使用命令 &lt;code&gt;git push origin master&lt;/code&gt; 推送最新修改&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Github" scheme="http://note.chenteng.me/tags/Github/"/>
    
      <category term="Git" scheme="http://note.chenteng.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》学习-22.4-自定义事件</title>
    <link href="http://note.chenteng.me/2016/08/17/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>http://note.chenteng.me/2016/08/17/自定义事件/</id>
    <published>2016-08-17T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义事件基本模式"><a href="#自定义事件基本模式" class="headerlink" title="自定义事件基本模式"></a>自定义事件基本模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handlers = &#123;&#125;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: EventTarget,</span><br><span class="line"></span><br><span class="line">    addHandler: function(type, handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.handlers[type] == <span class="string">"undefined"</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.handlers[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.handlers[type].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    fire: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!event.target)&#123;</span><br><span class="line">            event.target = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[event.type];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                handlers[i](event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[type];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (handlers[i] === handler)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            handlers.splice(i, <span class="number">1</span>);</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用EventTarget类型的自定义事件"><a href="#使用EventTarget类型的自定义事件" class="headerlink" title="使用EventTarget类型的自定义事件"></a>使用EventTarget类型的自定义事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"Message received: "</span> + event.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">new</span> EventTarget();</span><br><span class="line"></span><br><span class="line">target.addHandler(<span class="string">"message"</span>, handleMessage);</span><br><span class="line"></span><br><span class="line">target.fire(&#123;</span><br><span class="line">type: <span class="string">"message"</span>,</span><br><span class="line">message: <span class="string">"Hello world!"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.removeHandler(<span class="string">"message"</span>, handleMessage);</span><br><span class="line"></span><br><span class="line">target.fire(&#123;</span><br><span class="line">type: <span class="string">"message"</span>,</span><br><span class="line">message: <span class="string">"Hello world!"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="其它对象继承EventTarget"><a href="#其它对象继承EventTarget" class="headerlink" title="其它对象继承EventTarget"></a>其它对象继承EventTarget</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;  <span class="comment">//使用寄生组合继承</span></span><br><span class="line"><span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//create object</span></span><br><span class="line">prototype.constructor = subType; <span class="comment">//augment object</span></span><br><span class="line">subType.prototype = prototype; <span class="comment">//assign object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">EventTarget.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Person, EventTarget);</span><br><span class="line"></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.fire(&#123;</span><br><span class="line">type: <span class="string">"message"</span>,</span><br><span class="line">message: message</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">alert(event.target.name + <span class="string">" says: "</span> + event.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line">person.addHandler(<span class="string">"message"</span>, handleMessage);</span><br><span class="line"></span><br><span class="line">person.say(<span class="string">"Hi there."</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义事件基本模式&quot;&gt;&lt;a href=&quot;#自定义事件基本模式&quot; class=&quot;headerlink&quot; title=&quot;自定义事件基本模式&quot;&gt;&lt;/a&gt;自定义事件基本模式&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EventTarget&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers = &amp;#123;&amp;#125;;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EventTarget.prototype = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;: EventTarget,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addHandler: function(type, handler)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[type] == &lt;span class=&quot;string&quot;&gt;&quot;undefined&quot;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[type] = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[type].push(handler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fire: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!event.target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            event.target = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[event.type] &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; handlers = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[event.type];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len=handlers.length; i &amp;lt; len; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                handlers[i](event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    removeHandler: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;type, handler&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[type] &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; handlers = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handlers[type];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len=handlers.length; i &amp;lt; len; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (handlers[i] === handler)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            handlers.splice(i, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="原生JS" scheme="http://note.chenteng.me/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>用 Canvas 编织璀璨星空图</title>
    <link href="http://note.chenteng.me/2016/06/14/Canvas-CyandevToys/"/>
    <id>http://note.chenteng.me/2016/06/14/Canvas-CyandevToys/</id>
    <published>2016-06-14T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自： <a href="http://www.jianshu.com/p/f5c0f9c4bc39#" target="_blank" rel="noopener">简书-用 Canvas 编织璀璨星空图</a><br>作者：<a href="http://www.jianshu.com/users/c49454e0ae54" target="_blank" rel="noopener">Cyandev</a></p></blockquote><p>先来看看最终的效果：<br><img src="/images/CyandevToys.png" alt="璀璨星空图"></p><p>GitHub项目: <a href="https://github.com/unixzii/CyandevToys/tree/master/ParticleWeb" target="_blank" rel="noopener">CyandevToys / ParticleWeb</a></p><p>是不是还蛮酷的呢？本文我们就来一点一点分析怎么实现它！</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们看看这个效果具体有那些要点。首先，这么炫酷的效果肯定是要用到 Canvas 了，每个星星可以看作为一个粒子，因此，整个效果实际上就是粒子系统了。此外，我们可以发现每个粒子之间是相互连接的，只不过离的近的粒子之间的连线较粗且透明度较低，而离的远的则相反。</p><h2 id="开始-Coding"><a href="#开始-Coding" class="headerlink" title="开始 Coding"></a>开始 Coding</h2><h3 id="HTML-部分"><a href="#HTML-部分" class="headerlink" title="HTML 部分"></a>HTML 部分</h3><p>这部分我就简单放了一个 <code>&lt;canvas&gt;</code> 标签，设置样式使其填充全屏。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">height</span>=<span class="string">"620"</span> <span class="attr">width</span>=<span class="string">"1360"</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">style</span>=<span class="string">"position: absolute; height: 100%;"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后为了让所有元素没有间距和内补，我还加了一条全局样式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h3 id="JavaScript-部分"><a href="#JavaScript-部分" class="headerlink" title="JavaScript 部分"></a>JavaScript 部分</h3><p>下面我们来写核心的代码。首先我们要得到那个 canvas 并得到绘制上下文：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvasEl = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvasEl.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> mousePos = [<span class="number">0</span>, <span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>紧接着我们声明两个变量，分别用于存储“星星”和边：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = [];</span><br><span class="line"><span class="keyword">var</span> edges = [];</span><br></pre></td></tr></table></figure></p><p>下一步，我们做些准备工作，就是让画布在窗口大小发生变化时重新绘制，并且调整自身分辨率：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canvasEl.width = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    canvasEl.height = canvasEl.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodes.length == <span class="number">0</span>) &#123;</span><br><span class="line">      constructNodes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize(); <span class="comment">// trigger the event manually.</span></span><br></pre></td></tr></table></figure></p><p>我们在第一次修改大小后构建了所有节点，这里就要用到下一个函数<code>（constructNodes）</code>了</p><p>这个函数中我们随机创建几个点，我们用字典对象的方式存储这些点的各个信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructNodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> node = &#123;</span><br><span class="line">        drivenByMouse: i == <span class="number">0</span>,</span><br><span class="line">        x: <span class="built_in">Math</span>.random() * canvasEl.width,</span><br><span class="line">        y: <span class="built_in">Math</span>.random() * canvasEl.height,</span><br><span class="line">        vx: <span class="built_in">Math</span>.random() * <span class="number">1</span> - <span class="number">0.5</span>,</span><br><span class="line">        vy: <span class="built_in">Math</span>.random() * <span class="number">1</span> - <span class="number">0.5</span>,</span><br><span class="line">        radius: <span class="built_in">Math</span>.random() &gt; <span class="number">0.9</span> ? <span class="number">3</span> + <span class="built_in">Math</span>.random() * <span class="number">3</span> : <span class="number">1</span> + <span class="built_in">Math</span>.random() * <span class="number">3</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      nodes.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == e2) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> edge = &#123;</span><br><span class="line">          <span class="keyword">from</span>: e,</span><br><span class="line">          to: e2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addEdge(edge);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>为了实现后面一个更炫酷的效果，我给第一个点加了一个 drivenByMouse 属性，这个点的位置不会被粒子系统管理，也不会绘制出来，但是它会与其他点连线，这样就实现了鼠标跟随的效果了。</p><p>这里稍微解释一下 radius 属性的取值，我希望让绝大部分点都是小半径的，而极少数的点半径比较大，所以我这里用了一点小 tricky，就是用概率控制点的半径取值，不断调整这个概率阈值就能获取期待的半径随机分布。</p><p>点都构建完毕了，就要构建点与点之间的连线了，我们用到双重遍历，把两个点捆绑成一组，放到 <code>edges</code> 数组中。注意这里我用了另外一个函数来完成这件事，而没有直接用 <code>edges.push()</code> ，为什么？</p><p>假设我们之前连接了 A、B两点，也就是外侧循环是A，内侧循环是B，那么在下一次循环中，外侧为B，内侧为A，是不是也会创建一条边呢？而实际上，这两个边除了方向不一样以外是完全一样的，这完全没有必要而且占用资源。因此我们在 addEdge 函数中进行一个判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEdge</span>(<span class="params">edge</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ignore = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    edges.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.from == edge.from &amp;&amp; e.to == edge.to) &#123;</span><br><span class="line">        ignore = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (e.to == edge.from &amp;&amp; e.from == edge.to) &#123;</span><br><span class="line">        ignore = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ignore) &#123;</span><br><span class="line">      edges.push(edge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们的准备工作就完毕了，下面我们要让点动起来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.drivenByMouse) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      e.x += e.vx;</span><br><span class="line">      e.y += e.vy;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">clamp</span>(<span class="params">min, max, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">          <span class="keyword">return</span> min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (e.x &lt;= <span class="number">0</span> || e.x &gt;= canvasEl.width) &#123;</span><br><span class="line">        e.vx *= <span class="number">-1</span>;</span><br><span class="line">        e.x = clamp(<span class="number">0</span>, canvasEl.width, e.x)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (e.y &lt;= <span class="number">0</span> || e.y &gt;= canvasEl.height) &#123;</span><br><span class="line">        e.vy *= <span class="number">-1</span>;</span><br><span class="line">        e.y = clamp(<span class="number">0</span>, canvasEl.height, e.y)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    adjustNodeDrivenByMouse();</span><br><span class="line">    render();</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adjustNodeDrivenByMouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    nodes[<span class="number">0</span>].x += (mousePos[<span class="number">0</span>] - nodes[<span class="number">0</span>].x) / easingFactor;</span><br><span class="line">    nodes[<span class="number">0</span>].y += (mousePos[<span class="number">1</span>] - nodes[<span class="number">0</span>].y) / easingFactor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>看到这么一大段代码不要害怕，其实做的事情很简单。这是粒子系统的核心，就是遍历粒子，并且更新其状态。更新的公式就是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = v + a</span><br><span class="line">s = s + v</span><br></pre></td></tr></table></figure></p><p>a是加速度，v是速度，s是位移。由于我们这里不涉及加速度，所以就不写了。然后我们需要作一个边缘的碰撞检测，不然我们的“星星”都无拘无束地一点点飞～走～了～。边缘碰撞后的处理方式就是让速度矢量反转，这样粒子就会“掉头”回来。</p><p>还记得我们需要做的鼠标跟随吗？也在这处理，我们让第一个点的位置一点一点移动到鼠标的位置，下面这个公式很有意思，可以轻松实现缓动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + (t - x) / factor</span><br></pre></td></tr></table></figure></p><p>其中 factor 是缓动因子，t 是最终位置，x 是当前位置。至于这个公式的解释还有个交互大神 Bret Victor 在他的演讲中提到过，视频做的非常好，有<em>条(ti)件(zi)</em>大家一定要看看： <a href="https://www.youtube.com/watch?v=ZfytHvgHybA" target="_blank" rel="noopener">Bret Victor - Stop Drawing Dead Fish</a></p><p>好了，回到主题。我们在上面的函数中处理完了一帧中的数据，我们要让整个粒子系统连续地运转起来就需要一个timer了，但是十分不提倡大家使用 <code>setInterval</code>，而是尽可能使用 <code>requestAnimationFrame</code>，它能保证你的帧率锁定在 &lt;= 60 fps ，不至于爆掉你的浏览器。函数参数即为回调函数，看起来有点像递归调用，但实际上，浏览器内部处理是将这个回调函数先入事件列队，等所有绘制计算工作完毕后再从列队中取出执行，十分高效。</p><p>剩下的就是绘制啦：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.fillStyle = backgroundColor;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvasEl.width, canvasEl.height);</span><br><span class="line"></span><br><span class="line">    edges.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> l = lengthOfEdge(e);</span><br><span class="line">      <span class="keyword">var</span> threshold = canvasEl.width / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ctx.strokeStyle = edgeColor;</span><br><span class="line">      ctx.lineWidth = (<span class="number">1.0</span> - l / threshold) * <span class="number">2.5</span>;</span><br><span class="line">      ctx.globalAlpha = <span class="number">1.0</span> - l / threshold;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.moveTo(e.from.x, e.from.y);</span><br><span class="line">      ctx.lineTo(e.to.x, e.to.y);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.globalAlpha = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.drivenByMouse) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ctx.fillStyle = nodeColor;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.arc(e.x, e.y, e.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">      ctx.fill();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>常规的 <strong><code>Canvas</code></strong> 绘图操作，注意 <code>beginPath</code> 一定要调用，不然你的线就全部穿在一起了… 需要说明的是，在绘制边的时候，我们先要计算两点距离，然后根据一个阈值来判断是否要绘制这条边，这样我们才能实现距离远的点之间连线不可见的效果。</p><p>到这里，我们的整个效果就完成了。如果不明白大家也可以去我文章开头放的 repo 离去看完整的源码。Have fun!!</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自： &lt;a href=&quot;http://www.jianshu.com/p/f5c0f9c4bc39#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简书-用 Canvas 编织璀璨星空图&lt;/a&gt;&lt;br&gt;作者：&lt;a href=&quot;http://www.jianshu.com/users/c49454e0ae54&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cyandev&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来看看最终的效果：&lt;br&gt;&lt;img src=&quot;/images/CyandevToys.png&quot; alt=&quot;璀璨星空图&quot;&gt;&lt;/p&gt;
&lt;p&gt;GitHub项目: &lt;a href=&quot;https://github.com/unixzii/CyandevToys/tree/master/ParticleWeb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CyandevToys / ParticleWeb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是不是还蛮酷的呢？本文我们就来一点一点分析怎么实现它！&lt;/p&gt;
    
    </summary>
    
      <category term="精品转载" scheme="http://note.chenteng.me/categories/%E7%B2%BE%E5%93%81%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="Canvas" scheme="http://note.chenteng.me/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》学习-5.2-Array</title>
    <link href="http://note.chenteng.me/2016/05/31/professionalJS-Array/"/>
    <id>http://note.chenteng.me/2016/05/31/professionalJS-Array/</id>
    <published>2016-05-31T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《JavaScript高级程序设计》俗称“红宝书”，一直被列为前端人员必读经典，奉为前端圣经。买红宝书到现在很久了，刚开始一直拿他当工具书用，买了不久我又入手了更为适合当工具书的“犀牛书”，所以到现在红宝书都还没有完整的过一遍，实感不安。最近计划利用闲暇时间过一遍，为加深印象留下笔记。此为第五章：引用类型中的第三节：Array类型的讲解，较为基础。</p></blockquote><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>ECMAScript中的数组是常用的引用类型之一，秉承js松散类型的特点，js数组的每一项都可以保存任何类型的数据，并且数组的大小是可以动态调整的。<br>数组的基本创建方法有两种：</p><ol><li>使用Array构造函数：<code>var arr = new Array(3)</code>；<br>如上写法创建了一个长度为3的数组，</li><li>使用数组字面量：<code>var arr = [1,2,3]</code>；<br>此写法较为常用，需要注意的是<code>[1,2,]</code>这种最后一项为空的写法IE8-会认为数组长度为2，而现代浏览器会认为长度为3，故尽量避免出现该问题。</li></ol><p>可以改变数组的<code>length</code>属性值来为数组扩容（缩容），扩容后的数组被跳过的项的指为<code>undefined</code>。</p><a id="more"></a><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>检测一个对象是不是数组有2种方法：</p><ol><li>使用<code>instanceof</code>操作符：<code>value instanceof Array</code>;<br>解读为value是否为Array的一个实例。该方法的局限性在于：假定只有一个全局执行环境。</li><li>使用ES5中新增的<code>Array.isArray()</code>方法；<br>该方法判断准确，但只能在现代浏览器中使用。</li></ol><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>数组继承对象的<code>toLocaleString()</code>，<code>toString()</code>，<code>valueOf()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line">alert(colors.toString());  <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors.valueOf());   <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors);             <span class="comment">//red,green,blue</span></span><br></pre></td></tr></table></figure></p><p>直接alert数组时会隐式的调用数组的<code>toString()</code>方法。这三种方法都是返回数组中每个元素以<code>,</code>分隔的结果，可以调用数组的<code>join(&quot;分隔符&quot;)</code>来以自定义的分隔符分隔数组。</p><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><ol><li><code>push()</code>:添加任意项到数组末尾–推入，末尾入栈</li><li><code>pop()</code>:</li></ol><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《JavaScript高级程序设计》俗称“红宝书”，一直被列为前端人员必读经典，奉为前端圣经。买红宝书到现在很久了，刚开始一直拿他当工具书用，买了不久我又入手了更为适合当工具书的“犀牛书”，所以到现在红宝书都还没有完整的过一遍，实感不安。最近计划利用闲暇时间过一遍，为加深印象留下笔记。此为第五章：引用类型中的第三节：Array类型的讲解，较为基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Array类型&quot;&gt;&lt;a href=&quot;#Array类型&quot; class=&quot;headerlink&quot; title=&quot;Array类型&quot;&gt;&lt;/a&gt;Array类型&lt;/h2&gt;&lt;p&gt;ECMAScript中的数组是常用的引用类型之一，秉承js松散类型的特点，js数组的每一项都可以保存任何类型的数据，并且数组的大小是可以动态调整的。&lt;br&gt;数组的基本创建方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Array构造函数：&lt;code&gt;var arr = new Array(3)&lt;/code&gt;；&lt;br&gt;如上写法创建了一个长度为3的数组，&lt;/li&gt;
&lt;li&gt;使用数组字面量：&lt;code&gt;var arr = [1,2,3]&lt;/code&gt;；&lt;br&gt;此写法较为常用，需要注意的是&lt;code&gt;[1,2,]&lt;/code&gt;这种最后一项为空的写法IE8-会认为数组长度为2，而现代浏览器会认为长度为3，故尽量避免出现该问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以改变数组的&lt;code&gt;length&lt;/code&gt;属性值来为数组扩容（缩容），扩容后的数组被跳过的项的指为&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="原生JS" scheme="http://note.chenteng.me/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客Bug：“{{”符号引起的生成报错</title>
    <link href="http://note.chenteng.me/2016/05/24/HexoBug/"/>
    <id>http://note.chenteng.me/2016/05/24/HexoBug/</id>
    <published>2016-05-24T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Hexo写博客的一个小插曲"><a href="#使用Hexo写博客的一个小插曲" class="headerlink" title="使用Hexo写博客的一个小插曲"></a>使用Hexo写博客的一个小插曲</h2><p>从发现Hexo那天起，他就让我难以忘怀。这个小巧的静态博客框架搭建简单，无需复杂的配置，更不用自己写一行的代码就可以圆自己的博客梦。这让我这样对后台一无所知的小白也搜集教程，搭建了现在的这个博客。<br>Hexo的使用非常简便，写好markdown文件后只需要一个简单的指令<code>hexo d -g</code>就能完成从md到html的编译并且部署到服务器。<br>新博客搭建不久当我写到第6篇博客<a href="http://pages.fedt.xin/2016/05/22/AvalonJS01/" target="_blank" rel="noopener">AvalonJS系列01之快速入门</a>时，突然出现了问题：输入<code>hexo generate</code>指令生成时报错了！错误提示如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">INFO  Start processing</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: (unknown path) [Line 20, Column 83]</span><br><span class="line">  unexpected token: &#125; &#125;</span><br><span class="line">    at Object.exports.prettifyError (E:\Hexo\node_modules\nunjucks\src\lib.js:34:15)</span><br><span class="line">    at Obj.extend.render (E:\Hexo\node_modules\nunjucks\src\environment.js:468:27)</span><br><span class="line">    at Obj.extend.renderString (E:\Hexo\node_modules\nunjucks\src\environment.js:326:21)</span><br><span class="line">    at E:\Hexo\node_modules\hexo\lib\extend\tag.js:66:9</span><br><span class="line">    at Promise._execute (E:\Hexo\node_modules\bluebird\js\release\debuggability.js:272:9)</span><br><span class="line">    at Promise._resolveFromExecutor (E:\Hexo\node_modules\bluebird\js\release\promise.js:473:18)</span><br><span class="line">    at new Promise (E:\Hexo\node_modules\bluebird\js\release\promise.js:77:14)</span><br><span class="line">    at Tag.render (E:\Hexo\node_modules\hexo\lib\extend\tag.js:64:10)</span><br><span class="line">    at Object.tagFilter [as onRenderEnd] (E:\Hexo\node_modules\hexo\lib\hexo\post.js:253:16)</span><br><span class="line">    at E:\Hexo\node_modules\hexo\lib\hexo\render.js:63:19</span><br><span class="line">    at tryCatcher (E:\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (E:\Hexo\node_modules\bluebird\js\release\promise.js:502:31)</span><br><span class="line">    at Promise._settlePromise (E:\Hexo\node_modules\bluebird\js\release\promise.js:559:18)</span><br><span class="line">    at Promise._settlePromise0 (E:\Hexo\node_modules\bluebird\js\release\promise.js:604:10)</span><br><span class="line">    at Promise._settlePromises (E:\Hexo\node_modules\bluebird\js\release\promise.js:683:18)</span><br><span class="line">    at Async._drainQueue (E:\Hexo\node_modules\bluebird\js\release\async.js:138:16)</span><br><span class="line">    at Async._drainQueues (E:\Hexo\node_modules\bluebird\js\release\async.js:148:10)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (E:\Hexo\node_modules\bluebird\js\release\async.js:17:14)</span><br><span class="line">    at tryOnImmediate (timers.js:543:15)</span><br><span class="line">    at processImmediate [as _immediateCallback] (timers.js:523:5)</span><br><span class="line">FATAL (unknown path) [Line 20, Column 83]</span><br><span class="line">  unexpected token: &#125;&#125;</span><br><span class="line">Template render error: (unknown path) [Line 20, Column 83]</span><br><span class="line">  unexpected token: &#125;&#125;</span><br><span class="line">    at Object.exports.prettifyError (E:\Hexo\node_modules\nunjucks\src\lib.js:34:15)</span><br><span class="line">    at Obj.extend.render (E:\Hexo\node_modules\nunjucks\src\environment.js:468:27)</span><br><span class="line">    at Obj.extend.renderString (E:\Hexo\node_modules\nunjucks\src\environment.js:326:21)</span><br><span class="line">    at E:\Hexo\node_modules\hexo\lib\extend\tag.js:66:9</span><br><span class="line">    at Promise._execute (E:\Hexo\node_modules\bluebird\js\release\debuggability.js:272:9)</span><br><span class="line">    at Promise._resolveFromExecutor (E:\Hexo\node_modules\bluebird\js\release\promise.js:473:18)</span><br><span class="line">    at new Promise (E:\Hexo\node_modules\bluebird\js\release\promise.js:77:14)</span><br><span class="line">    at Tag.render (E:\Hexo\node_modules\hexo\lib\extend\tag.js:64:10)</span><br><span class="line">    at Object.tagFilter [as onRenderEnd] (E:\Hexo\node_modules\hexo\lib\hexo\post.js:253:16)</span><br><span class="line">    at E:\Hexo\node_modules\hexo\lib\hexo\render.js:63:19</span><br><span class="line">    at tryCatcher (E:\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (E:\Hexo\node_modules\bluebird\js\release\promise.js:502:31)</span><br><span class="line">    at Promise._settlePromise (E:\Hexo\node_modules\bluebird\js\release\promise.js:559:18)</span><br><span class="line">    at Promise._settlePromise0 (E:\Hexo\node_modules\bluebird\js\release\promise.js:604:10)</span><br><span class="line">    at Promise._settlePromises (E:\Hexo\node_modules\bluebird\js\release\promise.js:683:18)</span><br><span class="line">    at Async._drainQueue (E:\Hexo\node_modules\bluebird\js\release\async.js:138:16)</span><br><span class="line">    at Async._drainQueues (E:\Hexo\node_modules\bluebird\js\release\async.js:148:10)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (E:\Hexo\node_modules\bluebird\js\release\async.js:17:14)</span><br><span class="line">    at tryOnImmediate (timers.js:543:15)</span><br><span class="line">    at processImmediate [as _immediateCallback] (timers.js:523:5)</span><br></pre></td></tr></table></figure><p>我自然是看不懂这是什么错，所以我只好重新安装一遍Hexo。但是当我再次生成时，仍然报这个错！！<br>这就有点尴尬了，一直都是简单无脑的Hexo为什么今天就调皮了呢？<br>随后我试着还原我之前的一些更改，当我删掉那篇博客后就能正常生成了。。这一现象让我把注意力放在了我的md文件上！<br>但是我一直都是这样写的，md文件没有什么语法错误，markdownPad生成的html也是正常的。于是我试着去看那冗长的错误提示：果然，第五行赫然写着<code>unexpected token: }}</code>！！我查看我的md文件，其中果然出现了“{ { } }”！！<br>问题就出在这“{ {”上面，他会让Hexo编译失败并报错！<br>找到了问题所在，但我并没有找到怎么解决这个问题，所以我只好用空格符隔开“{”，这样就不会生成失败啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用Hexo写博客的一个小插曲&quot;&gt;&lt;a href=&quot;#使用Hexo写博客的一个小插曲&quot; class=&quot;headerlink&quot; title=&quot;使用Hexo写博客的一个小插曲&quot;&gt;&lt;/a&gt;使用Hexo写博客的一个小插曲&lt;/h2&gt;&lt;p&gt;从发现Hexo那天起，他就让我难以忘怀。这个小巧的静态博客框架搭建简单，无需复杂的配置，更不用自己写一行的代码就可以圆自己的博客梦。这让我这样对后台一无所知的小白也搜集教程，搭建了现在的这个博客。&lt;br&gt;Hexo的使用非常简便，写好markdown文件后只需要一个简单的指令&lt;code&gt;hexo d -g&lt;/code&gt;就能完成从md到html的编译并且部署到服务器。&lt;br&gt;新博客搭建不久当我写到第6篇博客&lt;a href=&quot;http://pages.fedt.xin/2016/05/22/AvalonJS01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AvalonJS系列01之快速入门&lt;/a&gt;时，突然出现了问题：输入&lt;code&gt;hexo generate&lt;/code&gt;指令生成时报错了！错误提示如下：&lt;/p&gt;
    
    </summary>
    
      <category term="技术分享" scheme="http://note.chenteng.me/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Hexo" scheme="http://note.chenteng.me/tags/Hexo/"/>
    
      <category term="Hexo bug" scheme="http://note.chenteng.me/tags/Hexo-bug/"/>
    
  </entry>
  
  <entry>
    <title>AvalonJS系列01之快速入门</title>
    <link href="http://note.chenteng.me/2016/05/22/AvalonJS01/"/>
    <id>http://note.chenteng.me/2016/05/22/AvalonJS01/</id>
    <published>2016-05-22T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于AvalonJS"><a href="#关于AvalonJS" class="headerlink" title="关于AvalonJS"></a>关于AvalonJS</h2><h3 id="AvalonJS简介"><a href="#AvalonJS简介" class="headerlink" title="AvalonJS简介"></a>AvalonJS简介</h3><p>avalon是一个简单易用迷你的MVVM框架，为解决同一业务逻辑存在各种视图呈现而开发出来的。<br>MVVM将所有前端代码彻底分成两部分，视图的处理通过绑定实现（angular中叫指令）， 业务逻辑则集中在一个个叫VM的对象中处理。我们只要操作VM的数据，它就自然而然地神奇地同步到视图。<br>avalon的所有指令都是以ms-*命名。跟MicroSoft并没有关系。</p><h3 id="AvalonJS的优势"><a href="#AvalonJS的优势" class="headerlink" title="AvalonJS的优势"></a>AvalonJS的优势</h3><blockquote><p>&emsp;&emsp;绝对的优势就是降低了耦合， 让开发者从复杂的各种事件中挣脱出来。 举一个简单地例子， 同一个状态可能跟若干个事件的发生顺序与发生时的附加参数都有关系， 不用 MVC (包括 MVVM) 的情况下, 逻辑可能非常复杂而且脆弱。 并且通常需要在不同的地方维护相关度非常高的一些逻辑， 稍有疏忽就会酿成 bug 不能自拔。使用这类框架能从根本上降低应用开发的逻辑难度， 并且让应用更稳健。</p><p>&emsp;&emsp;除此之外， 也免去了一些重复的体力劳动， 一个 {value} 就代替了一行 $(selector).text(value)。 一些个常用的 directive 也能快速实现一些原本可能需要较多代码才能实现的功能</p></blockquote><a id="more"></a><ul><li>国产框架，文档易于阅读理解。对于我这种英语捉急的来说简直福音。。</li><li>容易上手，没有太多复杂的概念， 指令数量控制得当，个人感觉酷似angular</li><li>兼容性非常好， 支持IE6+，firefox3.5+, opera11+, safari5+, chrome4，甚至兼容很多的国产山寨浏览器（<del>这个不能算优点，只是符合国情。低版本和山寨浏览器都得死</del>~~）</li><li>无DOM操作。这是所有VMMV框架的一个共性，让开发者投入业务逻辑开发而不用在头疼的DOM操作上浪费时间</li><li>使用类似CSS的重叠覆盖机制，让各个ViewModel分区交替地渲染页面</li></ul><h3 id="avalon现在有三个分支"><a href="#avalon现在有三个分支" class="headerlink" title="avalon现在有三个分支:"></a>avalon现在有三个分支:</h3><ul><li>avalon.js 兼容IE6，标准浏览器, 及主流山寨浏览器(QQ, 猎豹, 搜狗, 360, 傲游);</li><li>avalon.modern.js 则只支持IE10等支持HTML5现代浏览器 ; </li><li>avalon.mobile.js，添加了触屏事件与fastclick支持，用于移动端。</li></ul><h2 id="初探AvalonJS"><a href="#初探AvalonJS" class="headerlink" title="初探AvalonJS"></a>初探AvalonJS</h2><h3 id="avalon简单实例"><a href="#avalon简单实例" class="headerlink" title="avalon简单实例"></a>avalon简单实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"avalon.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ms-controller</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">" background: #a9ea00;"</span> <span class="attr">ms-css-width</span>=<span class="string">"w"</span> <span class="attr">ms-css-height</span>=<span class="string">"h"</span>  <span class="attr">ms-click</span>=<span class="string">"click"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; w &#125;&#125; x &#123;&#123; h &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>W: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ms-duplex</span>=<span class="string">"w"</span> <span class="attr">data-duplex-event</span>=<span class="string">"change"</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>H: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ms-duplex</span>=<span class="string">"h"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">              var vm = avalon.define(&#123;</span></span><br><span class="line"><span class="undefined">                 $id: "box",</span></span><br><span class="line"><span class="undefined">                  w: 100,</span></span><br><span class="line"><span class="undefined">                  h: 100,</span></span><br><span class="line"><span class="undefined">                  click: function() &#123;</span></span><br><span class="line"><span class="undefined">                    vm.w = parseFloat(vm.w) + 10;</span></span><br><span class="line"><span class="undefined">                    vm.h = parseFloat(vm.h) + 10;</span></span><br><span class="line"><span class="undefined">                  &#125;</span></span><br><span class="line"><span class="undefined">              &#125;)</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们可以看到在JS中，没有任何一行操作DOM的代码，也没有选择器，非常干净。在HTML中， 我们发现就是多了一些以ms-开始的属性与<code>{ { } }</code>标记，有的是用于渲染样式， 有的是用于绑定事件。这些属性或标记，实质就是avalon的绑定系统的一部分。绑定（有的框架也将之称为指令）， 负责帮我们完成视图的各种操作，相当于一个隐形的jQuery。正因为有了绑定，我们就可以在JS代码专注业务逻辑本身， 写得更易维护的代码！</p><h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>不过上面的代码并不完整，它能工作，是因为框架默认会在<code>DOMReady</code>时扫描DOM树，将视图中的绑定属性与<code>{ { } }</code>插值表达式抽取出来，转换为求值函数与视图刷新函数。</p><p>上面的JS代码相当于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">avalon.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = avalon.define(&#123;</span><br><span class="line">          $id: <span class="string">"box"</span>,</span><br><span class="line">          w: <span class="number">100</span>,</span><br><span class="line">          h: <span class="number">100</span>,</span><br><span class="line">          click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             vm.w = <span class="built_in">parseFloat</span>(vm.w) + <span class="number">10</span>;</span><br><span class="line">             vm.h = <span class="built_in">parseFloat</span>(vm.h) + <span class="number">10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      avalon.scan()</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p><strong><code>avalon.scan</code></strong>是一个非常重要的方法，它有<strong>两个</strong>可选参数，第一个是扫描的起点元素，默认是HTML标签，第2个是VM对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line">    avalon.scan = <span class="function"><span class="keyword">function</span>(<span class="params">elem, vmodel</span>) </span>&#123;</span><br><span class="line">        elem = elem || root</span><br><span class="line">        <span class="keyword">var</span> vmodels = vmodel ? [].concat(vmodel) : []</span><br><span class="line">        scanTag(elem, vmodels)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="视图模型"><a href="#视图模型" class="headerlink" title="视图模型"></a>视图模型</h3><p>视图模型，<code>ViewModel</code>，也经常被略写成VM，是通过<code>avalon.define</code>方法进行定义。生成的对象会默认放到<code>avalon.vmodels</code>对象上。 每个VM在定义时必须指定$id。如果你有某些属性不想监听，可以直接将此属性名放到<code>$skipArray</code>数组中。</p><p>接着我们说一些重要的概念：</p><ul><li><strong><code>$id</code></strong>， 每个VM都有$id，如果VM的某一个属性是对象（并且它是可监控的），也会转换为一个VM，这个子VM也会默认加上一个$id。 但只有用户添加的那个最外面的$id会注册到<code>avalon.vmodels</code>对象上。</li><li><strong>监控属性</strong>，一般地，VM中的属性都会转换为此种属性，当我们以<code>vm.aaa = yyy</code>这种形式更改其值时，就会同步到视图上的对应位置上。</li><li><strong>计算属性</strong>，定义时为一个对象，并且只存在set,get两个函数或只有一个get一个函数。它是监控属性的高级形式，表示它的值是通过函数计算出来的，是依赖于其他属性合成出来的。</li><li><strong>监控数组</strong>，定义时为一个数组，它会添加了许多新方法，但一般情况下与普通数组无异，但调用它的<code>push</code>, <code>unshift</code>, <code>remove</code>, <code>pop</code>等方法会同步视图。</li><li><strong>非监控属性</strong>，这包括框架添加的$id属性，以<strong>$开头的属性</strong>，放在<strong><code>$skipArray</code></strong>数组中的属性，值为<strong>函数、元素节点、文本节点</strong>的属性，总之，改变它们的值不会产生同步视图的效果。<br><code>$skipArray</code> 是一个字符串数组，只能放<strong>当前对象的直接属性名</strong>，想禁止子对象的某个属性的监听，在那个<code>子对象</code>上再添加一个<code>$skipAray</code>数组就行了。</li></ul><p>视图里面，我们可以使用<code>ms-controller</code>, <code>ms-important</code>指定一个<strong>VM的作用域</strong>。</p><p>此外，在<code>ms-each, ms-with，ms-repeat</code>绑定属性中，它们会创建一个临时的VM，我们称之为代理VM， 用于放置<code>$key, $val, $index, $last, $first, $remove</code>等变量或方法。</p><p>另外，avalon<strong>不允许在VM定义之后，再追加新属性与方法</strong>，也<strong>不允许在define里面直接调用方法或ajax</strong></p><h3 id="如何更新VM中的属性-重点-："><a href="#如何更新VM中的属性-重点-：" class="headerlink" title="如何更新VM中的属性(重点)："></a>如何更新VM中的属性(重点)：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model : avalon.define(&#123;</span><br><span class="line">     $id:  <span class="string">"update"</span>, </span><br><span class="line">     aaa : <span class="string">"str"</span>,</span><br><span class="line">     bbb : <span class="literal">false</span>,</span><br><span class="line">     ccc : <span class="number">1223</span>,</span><br><span class="line">     time : <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">     simpleArray : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">     objectArray : [&#123;<span class="attr">name</span>: <span class="string">"a"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"b"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"c"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"d"</span>&#125;],</span><br><span class="line">     object : &#123;</span><br><span class="line">         o1: <span class="string">"k1"</span>,</span><br><span class="line">         o2: <span class="string">"k2"</span>,</span><br><span class="line">         o3: <span class="string">"k3"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     simpleArray : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">     objectArray : [&#123;<span class="attr">name</span>: <span class="string">"a"</span>, <span class="attr">value</span>: <span class="string">"aa"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"b"</span>, <span class="attr">value</span>: <span class="string">"bb"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"c"</span>, <span class="attr">value</span>: <span class="string">"cc"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"d"</span>, <span class="attr">value</span>: <span class="string">"dd"</span>&#125;],</span><br><span class="line">     object : &#123;</span><br><span class="line">         o1: <span class="string">"k1"</span>,</span><br><span class="line">         o2: <span class="string">"k2"</span>,</span><br><span class="line">         o3: <span class="string">"k3"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//如果是更新简单数据类型（string, boolean, number）或Date类型</span></span><br><span class="line">           model.aaa = <span class="string">"这是字符串"</span></span><br><span class="line">           model.bbb = <span class="literal">true</span></span><br><span class="line">           model.ccc = <span class="number">999999999999</span></span><br><span class="line">           <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span></span><br><span class="line">           model.time = <span class="keyword">new</span> <span class="built_in">Date</span>(date.setFullYear(<span class="number">2005</span>))</span><br><span class="line">       &#125;, <span class="number">2000</span>)</span><br><span class="line"> </span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//如果是数组，注意保证它们的元素的类型是一致的</span></span><br><span class="line">           <span class="comment">//只能全是字符串，或是全是布尔，不能有一些是这种类型，另一些是其他类型</span></span><br><span class="line">           <span class="comment">//这时我们可以使用set方法来更新（它有两个参数，第一个是index，第2个是新值）</span></span><br><span class="line">           model.simpleArray.set(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">           model.simpleArray.set(<span class="number">2</span>, <span class="number">3000</span>)</span><br><span class="line">           model.objectArray.set(<span class="number">0</span>, &#123;<span class="attr">name</span>: <span class="string">"xxxxxxxxxxxxxxxx"</span>, <span class="attr">value</span>: <span class="string">"xxx"</span>&#125;)</span><br><span class="line">       &#125;, <span class="number">2500</span>)</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           model.objectArray[<span class="number">1</span>].name = <span class="string">"5555"</span></span><br><span class="line">       &#125;, <span class="number">3000</span>)</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//如果要更新对象，直接赋给它一个对象，注意不能将一个VM赋给它，可以到VM的$model赋给它（要不会在IE6-8中报错）</span></span><br><span class="line">           model.object = &#123;</span><br><span class="line">               aaaa: <span class="string">"aaaa"</span>,</span><br><span class="line">               bbbb: <span class="string">"bbbb"</span>,</span><br><span class="line">               cccc: <span class="string">"cccc"</span>,</span><br><span class="line">               dddd: <span class="string">"dddd"</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>avalon的绑定（或指令），拥有以下三种类型：</p><ul><li><code>{ { } }</code>插值表达式， 这是开标签与闭标签间，换言之，也是位于<strong>文本节点</strong>中，<code>innerText</code>里。<code>{ { } }</code>里面可以添加各种过滤器（以|进行标识）。值得注意的是<code>{ { } }</code>实际是文本绑定(<code>ms-text</code>)的一种形式。</li><li><p>ms-*绑定属性， 这是位于开标签的内部， 95%的绑定都以这种形式存在。 它们的格式大概是这样划分的 <code>&quot;ms&quot; + type + &quot;-&quot; + param1 + &quot;-&quot; + param1 + &quot;-&quot; + param2 + ... + number = value</code>。关于绑定属性指令将在<a href="http://pages.fedt.xin/AvalonJS02/" target="_blank" rel="noopener">下一篇</a>中详细说到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ms-skip                <span class="comment">//这个绑定属性没有值</span></span><br><span class="line">ms-controller=<span class="string">"expr"</span>   <span class="comment">//这个绑定属性没有参数</span></span><br><span class="line">ms-<span class="keyword">if</span>=<span class="string">"expr"</span>           <span class="comment">//这个绑定属性没有参数</span></span><br><span class="line">ms-<span class="keyword">if</span>-loop=<span class="string">"expr"</span>       <span class="comment">//这个绑定属性有一个参数</span></span><br><span class="line">ms-repeat-el=<span class="string">"array"</span>    <span class="comment">//这个绑定属性有一个参数</span></span><br><span class="line">ms-attr-href=<span class="string">"xxxx"</span>    <span class="comment">//这个绑定属性有一个参数</span></span><br><span class="line">ms-attr-src=<span class="string">"xxx/&#123;&#123;a&#125;&#125;/yyy/&#123;&#123;b&#125;&#125;"</span>   <span class="comment">//这个绑定属性的值包含插值表达式，注意只有少部分表示字符串类型的属性可以使用插值表达式</span></span><br><span class="line">ms-click<span class="number">-1</span>=<span class="string">"fn"</span>       <span class="comment">//这个绑定属性的名字最后有数字，这是方便我们绑定更多点击事件 ms-click-2="fn"  ms-click-3="fn"  </span></span><br><span class="line">ms-on-click=<span class="string">"fn"</span>     <span class="comment">//只有表示事件与类名的绑定属性的可以加数字，如这个也可以写成  ms-on-click-0="fn"    </span></span><br><span class="line">ms-<span class="class"><span class="keyword">class</span>-1</span>=<span class="string">"xxx"</span> ms-<span class="class"><span class="keyword">class</span>-2</span>=<span class="string">"yyy"</span> ms-<span class="class"><span class="keyword">class</span>-3</span>=<span class="string">"xxx"</span> <span class="comment">//数字还表示绑定的次序</span></span><br><span class="line">ms-css-background-color=<span class="string">"xxx"</span> <span class="comment">//这个绑定属性有两个参数，但在css绑定里，相当于一个，会内部转换为backgroundColor </span></span><br><span class="line">ms-duplex-aaa-bbb-string=<span class="string">"xxx"</span><span class="comment">//这个绑定属性有三个参数，表示三种不同的拦截操作</span></span><br></pre></td></tr></table></figure></li><li><p><code>data-xxx-yyy=&quot;xxx&quot;</code>，辅助指令，比如ms-duplex的某一个辅助指令为<code>data-duplex-event=&quot;change&quot;</code>，<code>ms-repeat</code>的某一个辅助指令为<code>data-repeat-rendered=&quot;yyy&quot;</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于AvalonJS&quot;&gt;&lt;a href=&quot;#关于AvalonJS&quot; class=&quot;headerlink&quot; title=&quot;关于AvalonJS&quot;&gt;&lt;/a&gt;关于AvalonJS&lt;/h2&gt;&lt;h3 id=&quot;AvalonJS简介&quot;&gt;&lt;a href=&quot;#AvalonJS简介&quot; class=&quot;headerlink&quot; title=&quot;AvalonJS简介&quot;&gt;&lt;/a&gt;AvalonJS简介&lt;/h3&gt;&lt;p&gt;avalon是一个简单易用迷你的MVVM框架，为解决同一业务逻辑存在各种视图呈现而开发出来的。&lt;br&gt;MVVM将所有前端代码彻底分成两部分，视图的处理通过绑定实现（angular中叫指令）， 业务逻辑则集中在一个个叫VM的对象中处理。我们只要操作VM的数据，它就自然而然地神奇地同步到视图。&lt;br&gt;avalon的所有指令都是以ms-*命名。跟MicroSoft并没有关系。&lt;/p&gt;
&lt;h3 id=&quot;AvalonJS的优势&quot;&gt;&lt;a href=&quot;#AvalonJS的优势&quot; class=&quot;headerlink&quot; title=&quot;AvalonJS的优势&quot;&gt;&lt;/a&gt;AvalonJS的优势&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;绝对的优势就是降低了耦合， 让开发者从复杂的各种事件中挣脱出来。 举一个简单地例子， 同一个状态可能跟若干个事件的发生顺序与发生时的附加参数都有关系， 不用 MVC (包括 MVVM) 的情况下, 逻辑可能非常复杂而且脆弱。 并且通常需要在不同的地方维护相关度非常高的一些逻辑， 稍有疏忽就会酿成 bug 不能自拔。使用这类框架能从根本上降低应用开发的逻辑难度， 并且让应用更稳健。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;除此之外， 也免去了一些重复的体力劳动， 一个 {value} 就代替了一行 $(selector).text(value)。 一些个常用的 directive 也能快速实现一些原本可能需要较多代码才能实现的功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术分享" scheme="http://note.chenteng.me/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JS框架" scheme="http://note.chenteng.me/tags/JS%E6%A1%86%E6%9E%B6/"/>
    
      <category term="AvalonJS" scheme="http://note.chenteng.me/tags/AvalonJS/"/>
    
  </entry>
  
  <entry>
    <title>CSS垂直水平居中与z-index详解</title>
    <link href="http://note.chenteng.me/2016/05/21/CssAlignCenterZ-index/"/>
    <id>http://note.chenteng.me/2016/05/21/CssAlignCenterZ-index/</id>
    <published>2016-05-21T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优雅实现垂直水平居中的3种方法"><a href="#优雅实现垂直水平居中的3种方法" class="headerlink" title="优雅实现垂直水平居中的3种方法"></a>优雅实现垂直水平居中的3种方法</h2><ol><li><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4>使用绝对定位，并设置<code>left</code>,<code>right</code>,<code>top</code>,<code>bottom</code>为0，<code>margin:auto</code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol><li><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>父元素使用<code>flex</code>布局，<code>align-items: center;</code>：设置垂直居中，<code>justify-content: center;</code>：设置水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>使用相对定位，设置<code>top: 50%;</code>，此时的top值50%是相对父元素的，再用<code>translateY(-50%);</code>来转换，此时的-50%是相对自身高度的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);<span class="comment">/*margin-top:-200px*/</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="层叠顺序详解-z-index"><a href="#层叠顺序详解-z-index" class="headerlink" title="层叠顺序详解(z-index)"></a>层叠顺序详解(z-index)</h2><blockquote><p>参考链接：<a href="http://www.cnblogs.com/bfgis/p/5440956.html" target="_blank" rel="noopener">cnblog</a></p></blockquote><p>z-index可以设置成三个值：</p><ul><li><code>auto</code>，默认值。当设置成auto的时候，当前元素的层叠级数是0，同时这个盒子不会创建新的层级上下文；</li><li><code>&lt;integer&gt;</code>，指示层叠级数，可以是负值，同时无论是什么值，都会创建一个新的层叠上下文；</li><li><code>inherit</code>，父元素继承</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优雅实现垂直水平居中的3种方法&quot;&gt;&lt;a href=&quot;#优雅实现垂直水平居中的3种方法&quot; class=&quot;headerlink&quot; title=&quot;优雅实现垂直水平居中的3种方法&quot;&gt;&lt;/a&gt;优雅实现垂直水平居中的3种方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h4&gt;使用绝对定位，并设置&lt;code&gt;left&lt;/code&gt;,&lt;code&gt;right&lt;/code&gt;,&lt;code&gt;top&lt;/code&gt;,&lt;code&gt;bottom&lt;/code&gt;为0，&lt;code&gt;margin:auto&lt;/code&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;html&lt;/span&gt;,&lt;span class=&quot;selector-tag&quot;&gt;body&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;body&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;: relative;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.div&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;background-color&lt;/span&gt;: green;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;400px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;400px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;: absolute;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;left&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;right&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;top&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: auto;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="css" scheme="http://note.chenteng.me/tags/css/"/>
    
      <category term="垂直居中" scheme="http://note.chenteng.me/tags/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用Github的Pages服务搭建Hexo静态博客</title>
    <link href="http://note.chenteng.me/2016/05/18/HexoBlog/"/>
    <id>http://note.chenteng.me/2016/05/18/HexoBlog/</id>
    <published>2016-05-18T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h2><p>Hexo是使用Node.js实现的快速、间接且高效的博客框架。<br>Hexo的特点</p><ul><li>超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</li><li>支持MarkDown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</li><li>一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</li><li>丰富插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。<br>Hexo的官网：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></li></ul><a id="more"></a><h2 id="工具与环境"><a href="#工具与环境" class="headerlink" title="工具与环境"></a>工具与环境</h2><ul><li><a href="https://nodejs.org/en" rel="noopener" target="_blank">Node.js</a><br>无脑下一步安装，命令行测试<code>node</code>和<code>npm</code>指令</li><li><p><a href="http://git-scm.com" rel="noopener" target="_blank">Git</a><br>Git的安装也很简单粗暴，一路下一步。</p></li><li><p>如若想利用Github的Pages服务搭建博客则建立名为<code>yourusernam.github.io</code>的仓库，使用默认<code>master</code>分支即可。</p></li><li>若是想利用Coding(Gitcafe已被其收购)的Pages服务搭建博客则建立名为<code>yourusernam</code>的仓库，使用<code>coding-pages</code>分支。<blockquote><p>仓库命名均有严格规范，不可更改</p></blockquote></li></ul><h2 id="先介绍常用命令"><a href="#先介绍常用命令" class="headerlink" title="先介绍常用命令"></a>先介绍常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo generate = hexo g  //生成静态博客，即重新生成public文件夹</span><br><span class="line">hexo server = hexo s  //本地预览调试 (一般组合使用 hexo g &amp;&amp; hexo s)</span><br><span class="line">hexo delopy = hexo d //(发布到github)</span><br><span class="line">hexo new = hexo n //(执行该命令之后在source_posts目录下产生&lt; blog name &gt;.md文件，这是你的一篇新博客。可以在markdown工具下编写)</span><br><span class="line">hexo </span><br><span class="line">hexo clean //清除缓存,一般本地服务器效果有了但public文件没变化，则删除根目录的db.json再重新生成部署</span><br><span class="line">hexo d -g   //hexo d 和hexo g 的合并，生成并部署</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h4 id="安装Hexo到本地"><a href="#安装Hexo到本地" class="headerlink" title="安装Hexo到本地"></a>安装Hexo到本地</h4><pre><code>1. 在桌面下使用GIT Bash输入下面代码，实现Hexo的安装</code></pre><p><code>$ sudo npm install hexo-cli -g</code></p><pre><code>2. 命令行直接输入</code></pre><p><code>npm install hexo-cli -g</code></p><h4 id="初始化自己的个人博客"><a href="#初始化自己的个人博客" class="headerlink" title="初始化自己的个人博客"></a>初始化自己的个人博客</h4><pre><code>使用GIT Bash切换到你希望安装个人博客的文件夹下,输入命令：`$ hexo init folderName`folderName是你希望存放博客文件的文件夹名称</code></pre><h2 id="主题的安装"><a href="#主题的安装" class="headerlink" title="主题的安装"></a>主题的安装</h2><p>在完成上一步后，其实就可以运行查看页面了，这一步让你实现安装自己喜欢的主题，可以在Github网站中输入hexo关键字，可以搜索到很多相关主题，挑选一个就可以了</p><p>我这里使用NEXT这个主题进行讲解，其他的方式也是一样的。</p><p>使用GIT Bash切换到你刚才个人博客安装目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;blogFolder&gt;   //切换到博客的安装目录</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>完成上面步骤，会在theme的目录下多了一个next文件，说明主题下载成功了，但现在还没有配置完成</p><p>在<code>username.github.io</code>文件下有一个<code>_config.yml</code>文件，编辑它</p><p>将<code>theme</code>的<code>value</code>设为自己的主题名，这里是next——完成主题的配置</p><p>将<code>deploy</code>的<code>value</code>进行配置——完成主题发布地址配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><blockquote><p>这里可以添加多个仓库，repo：仓库名,分支名</p></blockquote><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><p>在<code>username.github.io/source/_posts</code>目录下创建你自己的文章，文章格式为Markdown的.md格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo让博客梦变的简单</span><br><span class="line">date: 2016-05-12</span><br><span class="line">---</span><br><span class="line">title:文章名，date:发布的日期</span><br></pre></td></tr></table></figure></p><h2 id="发布到Github"><a href="#发布到Github" class="headerlink" title="发布到Github"></a>发布到Github</h2><p>安装自动部署发布工具</p><p>使用GIT Bash切换到username.github.io目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">编译</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br><span class="line">本地测试</span><br><span class="line"></span><br><span class="line">$ hexo s -p 4000</span><br><span class="line">-p:设置端口号，默认为4000，使用默认端口可以省略</span><br></pre></td></tr></table></figure></p><p>本地测试没有问题后就可<code>hexo d -g</code>部署到github或者coding上面了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hexo介绍&quot;&gt;&lt;a href=&quot;#Hexo介绍&quot; class=&quot;headerlink&quot; title=&quot;Hexo介绍&quot;&gt;&lt;/a&gt;Hexo介绍&lt;/h2&gt;&lt;p&gt;Hexo是使用Node.js实现的快速、间接且高效的博客框架。&lt;br&gt;Hexo的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。&lt;/li&gt;
&lt;li&gt;支持MarkDown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/li&gt;
&lt;li&gt;一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。&lt;/li&gt;
&lt;li&gt;丰富插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。&lt;br&gt;Hexo的官网：&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术分享" scheme="http://note.chenteng.me/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Github" scheme="http://note.chenteng.me/tags/Github/"/>
    
      <category term="Hexo" scheme="http://note.chenteng.me/tags/Hexo/"/>
    
      <category term="静态博客" scheme="http://note.chenteng.me/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式学习笔记1</title>
    <link href="http://note.chenteng.me/2016/05/13/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%9701/"/>
    <id>http://note.chenteng.me/2016/05/13/JS设计模式系列01/</id>
    <published>2016-05-13T16:36:54.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习SegmentFault上的 <code>JavaScript</code>设计模式 笔记<br>原文：<a href="https://segmentfault.com/a/1190000003923665" rel="noopener" target="_blank">听飞狐聊JavaScript设计模式系列01</a><br>系列一主要回顾ES5中数组的方法，除原文介绍还查阅了MDN相关资料</p></blockquote><h2 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some()"></a><code>Array.prototype.some()</code></h2><blockquote><p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener" target="_blank">MDN-Array.prototype.some()</a></p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>arr.some(callback[, thisArg])</code><br><a id="more"></a></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>callback<br>用来测试每个元素的函数。<br>thisArg<br>执行 callback 时使用的 this 值。</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>some 为数组中的每一个元素执行一次 callback 函数，<strong>直到找到一个使得 callback 返回一个“真值”</strong>（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p><p>callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。</p><p>如果为 some 提供了一个 thisArg 参数，将会把它传给被调用的 callback，作为 this 值。否则，在非严格模式下将会是全局对象，严格模式下是 undefined。</p><p>some 被调用时不会改变数组。</p><p>some 遍历的元素的范围在第一次调用 callback. 时就已经确定了。在调用 some 后被添加到数组中的值不会被 callback 访问到。如果数组中存在且还未被访问到的元素被 callback 改变了，则其传递给 callback 的值是 some 访问到它那一刻的值。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>例子：测试数组元素的值</p><p>下面的例子检测在数组中是否有元素大于 10。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p><h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a><code>Array.prototype.reduce()</code></h2><blockquote><p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener" target="_blank">MDN-Array.prototype.reduce</a></p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始<strong>合并</strong>，最终为一个值。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>callback</strong><br>执行数组中每个值的函数，包含四个参数<ul><li><strong>previousValue</strong><br>上一次调用回调返回的值，或者是提供的初始值（initialValue）</li><li><strong>currentValue</strong><br>数组中当前被处理的元素</li><li><strong>index</strong><br>当前元素在数组中的索引</li><li><strong>array</strong><br>调用 reduce 的数组</li></ul></li><li><strong>initialValue</strong><br>作为第一次调用 callback 的第一个参数。</li></ul><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p><code>reduce()</code> 为数组中的每一个元素依次执行回调函数，<strong>不包括</strong>数组中<strong>被删除</strong>或<strong>从未被赋值</strong>的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 <code>reduce</code> 的数组。</p><p>回调函数<strong>第一次</strong>执行时，<code>previousValue</code> 和 <code>currentValue</code> 可以是一个值，如果在调用 <code>reduce()</code> 时提供了初始值 <code>initialValue</code>，那么第一个 <code>previousValue</code> 等于 <code>initialValue</code> ，并且<code>currentValue</code> 等于数组中的第一个值；如果<code>initialValue</code> 未被提供，那么<code>previousValue</code> 等于数组中的第一个值，<code>currentValue</code>等于数组中的第二个值。</p><p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p><p><strong>例</strong>：如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, currentValue, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>调用次数</th><th style="text-align:center">previousValue</th><th style="text-align:center">currentValue</th><th style="text-align:center">index</th><th style="text-align:center">array</th><th style="text-align:center">return value</th></tr></thead><tbody><tr><td>第一次调用</td><td style="text-align:center">10</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">[0,1,2,3,4]</td><td style="text-align:center">10</td></tr><tr><td>第二次调用</td><td style="text-align:center">10</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">[0,1,2,3,4]</td><td style="text-align:center">11</td></tr><tr><td>第三次调用</td><td style="text-align:center">11</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">[0,1,2,3,4]</td><td style="text-align:center">13</td></tr><tr><td>第四次调用</td><td style="text-align:center">13</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">[0,1,2,3,4]</td><td style="text-align:center">16</td></tr><tr><td>第五次调用</td><td style="text-align:center">16</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">[0,1,2,3,4]</td><td style="text-align:center">20</td></tr></tbody></table><h4 id="使用reduce-扁平化数组-降维"><a href="#使用reduce-扁平化数组-降维" class="headerlink" title="使用reduce()扁平化数组(降维)"></a>使用<code>reduce()</code>扁平化数组(降维)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="ES5中数组的新特性"><a href="#ES5中数组的新特性" class="headerlink" title="ES5中数组的新特性"></a>ES5中数组的新特性</h2><blockquote><p>来源：<a href="https://segmentfault.com/a/1190000003923665" rel="noopener" target="_blank">听飞狐聊JavaScript设计模式系列01</a></p></blockquote><p>ECMAScript5中数组的新特性，个人做了如下区分：</p><ul><li>位置方法：<code>indexOf</code>，<code>lastIndexOf</code></li><li>迭代方法：<code>every</code>，<code>filter</code>，<code>forEach</code>，<code>some</code>，<code>map</code></li><li>缩小方法：<code>reduce</code>，<code>reduceRight</code></li></ul><p><em>注</em>：<strong>迭代方法</strong>回调支持<strong>3个参数</strong>，第1个是遍历的数组内容(<code>currentElement</code>)；第2个是对应的数组索引(<code>index</code>)，第3个是数组本身(<code>array</code>)</p><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><p>对数组的每个元素都进行函数运行，如果<strong>每个</strong>都是true，则返回true，否则，如果有一个是false，那就返回false咯<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"卫士"</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="string">"包裹"</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="string">"皮带"</span>,<span class="string">"包裹"</span>,<span class="string">"包裹"</span>];</span><br><span class="line">   <span class="keyword">var</span> res = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">typeof</span> item==<span class="string">"string"</span>;    </span><br><span class="line">   &#125;)    </span><br><span class="line">   alert(res);    <span class="comment">// false，把数组中的数字项全部去掉，则返回true</span></span><br></pre></td></tr></table></figure></p><h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><p>对数组的每个元素都进行函数运行，对<strong>任一项</strong>返回为true，则返回为true，跟上面的every相似，好像every是处女座样(^__^)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">6</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(res);    <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure></p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>对数组的每个元素都进行函数运行，返回过滤后的选项<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"卫士"</span>,<span class="number">23</span>,<span class="string">"包裹"</span>,<span class="number">565</span>,<span class="string">"皮带"</span>,<span class="string">"包裹"</span>,<span class="string">"包裹"</span>];</span><br><span class="line">   <span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">typeof</span> item==<span class="string">"string"</span>;</span><br><span class="line">   &#125;)    </span><br><span class="line">   alert(res);    <span class="comment">// 卫士, 包裹, 皮带, 包裹, 包裹</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习SegmentFault上的 &lt;code&gt;JavaScript&lt;/code&gt;设计模式 笔记&lt;br&gt;原文：&lt;a href=&quot;https://segmentfault.com/a/1190000003923665&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;听飞狐聊JavaScript设计模式系列01&lt;/a&gt;&lt;br&gt;系列一主要回顾ES5中数组的方法，除原文介绍还查阅了MDN相关资料&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Array-prototype-some&quot;&gt;&lt;a href=&quot;#Array-prototype-some&quot; class=&quot;headerlink&quot; title=&quot;Array.prototype.some()&quot;&gt;&lt;/a&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;MDN-Array.prototype.some()&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h4&gt;&lt;p&gt;&lt;code&gt;arr.some(callback[, thisArg])&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="原生JS" scheme="http://note.chenteng.me/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript杂记(RAF,Selection,Scroll)</title>
    <link href="http://note.chenteng.me/2016/05/10/JavaScriptWiki/"/>
    <id>http://note.chenteng.me/2016/05/10/JavaScriptWiki/</id>
    <published>2016-05-10T14:55:16.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="reqeustAnimationFrame-RAF"><a href="#reqeustAnimationFrame-RAF" class="headerlink" title="reqeustAnimationFrame(RAF)"></a><code>reqeustAnimationFrame(RAF)</code></h2><blockquote><p>来自：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame" rel="noopener" target="_blank">MDN</a></p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>window.requestAnimationFrame()</strong>这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。这个方法接受一个函数为参，该函数会在重绘前调用。</p><p><strong>注意</strong>: 如果想得到连贯的逐帧动画，函数中必须重新调用 <code>requestAnimationFrame()</code>。</p><p>如果你想做逐帧动画的时候，你应该用这个方法。这就要求你的动画函数执行会先于浏览器重绘动作。通常来说，被调用的频率是每秒60次，但是一般会遵循W3C标准规定的频率。如果是后台标签页面，重绘频率则会大大降低。</p><p>回调函数只会被传入一个<code>DOMHighResTimeStamp</code>参数，这个参数指示当前被 <code>requestAnimationFrame</code> 序列化的函数队列被触发的时间。因为很多个函数在这一帧被执行，所以每个函数都将被传入一个相同的时间戳，尽管经过了之前很多的计算工作。这个数值是一个小数，单位毫秒，精确度在 10 µs。<br><a id="more"></a></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>callback</strong><br>在每次需要重新绘制动画时,会调用这个参数所指定的函数。这个回调函数会收到一个参数，这个 <code>DOMHighResTimeStamp</code> 类型的参数指示当前时间距离开始触发 <code>requestAnimationFrame</code> 的回调的时间。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><code>requestID</code> 是一个长整型非零值,作为一个唯一的标识符.你可以将该值作为参数传给 <code>window.cancelAnimationFrame()</code> 来取消这个回调函数。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>.requestAnimationFrame || <span class="built_in">window</span>.mozRequestAnimationFrame || <span class="built_in">window</span>.webkitRequestAnimationFrame || <span class="built_in">window</span>.msRequestAnimationFrame;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">'SomeElementYouWantToAnimate'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (start === <span class="literal">null</span>) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  d.style.left = <span class="built_in">Math</span>.min(progress/<span class="number">10</span>, <span class="number">200</span>) + <span class="string">"px"</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">      requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(step);</span><br></pre></td></tr></table></figure><h2 id="Selection对象"><a href="#Selection对象" class="headerlink" title="Selection对象"></a>Selection对象</h2><blockquote><p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection" rel="noopener" target="_blank">MDN</a></p></blockquote><p>Selection对象一般由<code>window.getSelection()</code>或其他方法产生。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。 如果你想了解关于其他容纳纯文本的表单元素中的选区操作，请参考 Input, TextArea 和 document.activeElement ，我们可以在这些页面元素中使用 window.getSelection()。</p><p>Selection对象所对应的是用户所选择的 ranges （区域），俗称拖蓝。默认情况下，该函数只针对一个区域，我们可以这样使用这个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selObj = <span class="built_in">window</span>.getSelection();</span><br><span class="line"><span class="keyword">var</span> range  = selObj.getRangeAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><ul><li>selObj 被赋予一个 Selection对象</li><li>range 被赋予一个 Range 对象</li></ul><p>调用 <code>Selection/toString()</code> 方法会返回被选中区域中的<strong>纯文本</strong>。要求变量为字符串的函数会自动对对象进行该处理，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selObj = <span class="built_in">window</span>.getSelection();</span><br><span class="line"><span class="built_in">window</span>.alert(selObj);</span><br></pre></td></tr></table></figure></p><h2 id="网页上的复制与剪切"><a href="#网页上的复制与剪切" class="headerlink" title="网页上的复制与剪切"></a>网页上的复制与剪切</h2><blockquote><p>来自：<a href="http://zencode.in/17.%E7%BD%91%E9%A1%B5%E4%B8%8A%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%89%AA%E5%88%87.html" rel="noopener" target="_blank">MZhou’s blog</a></p></blockquote><p>IE 10及以上的版本修改了Document.execCommand()方法，增加了对剪切和复制的支持。Chrome从43版本开始也支持了这项特性。</p><p>当选中了浏览器中的任意文本，只要执行这个方法就可以剪切或拷贝这段文字。有了这个API后，选中一段文字并拷贝会变的非常简单。</p><p>这个API和Selection API一起使用时将会变的特别有用。你可以决定哪些文本被复制到剪切版。之后我们会详细阐述。</p><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>让我们来增加一个按钮，点击这个按钮会拷贝一个email地址到用户的剪切版。</p><p>我们在网页里面添加一个email地址和一个按钮，点击按钮会拷贝email地址：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Email me at &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"js-emaillink"</span> href=<span class="string">"mailto:matt@example.co.uk"</span>&gt;matt@example.co.uk&lt;<span class="regexp">/a&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"js-emailcopybtn"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/copy-icon.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>接下来在Javascript中，我们增加一个click事件监听器到按钮上。在事件监听器中我们通过class js-emaillink选中email地址，然后执行拷贝命令，然后用户的剪切版里面就会有email地址了。然后我们取消选中email地址，这样用户就不会见到文本被选中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyEmailBtn = <span class="built_in">document</span>.querySelector(<span class="string">'.js-emailcopybtn'</span>);</span><br><span class="line">copyEmailBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// Select the email link anchor text</span></span><br><span class="line"><span class="keyword">var</span> emailLink = <span class="built_in">document</span>.querySelector(<span class="string">'.js-emaillink'</span>);</span><br><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</span><br><span class="line">range.selectNode(emailLink);</span><br><span class="line"><span class="built_in">window</span>.getSelection().addRange(range);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Now that we've selected the anchor text, execute the copy command</span></span><br><span class="line"><span class="keyword">var</span> successful = <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line"><span class="keyword">var</span> msg = successful ? <span class="string">'successful'</span> : <span class="string">'unsuccessful'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Copy email command was '</span> + msg);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Oops, unable to copy'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the selections - <span class="doctag">NOTE:</span> Should use</span></span><br><span class="line"><span class="comment">// removeRange(range) when it is supported</span></span><br><span class="line"><span class="built_in">window</span>.getSelection().removeAllRanges();</span><br></pre></td></tr></table></figure></p><p>如上代码中使用了<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection" rel="noopener" target="_blank">Selection API</a>的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection" rel="noopener" target="_blank">window.getSelection()</a>方法选中链接的文本。在document.execCommand()方法后，我们可以通过调用window.getSelection().removeAllRanges()方法来移除选中。如果你想检查拷贝是否成功，那么你可以checkdocument.execCommand();的返回值。如果返回false那么表示不支持拷贝或者不能使用（没有选中文本）。我们将execCommand()放到try catch里面执行是为了确保一些极端情况下浏览器会抛出错误。</p><p>剪切命令可以在文本框中使用。你可以移除文本输入框中的文字并放到剪切版中使用。</p><p>在HTML中添加一个textarea和一个按钮：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"js-cuttextarea"</span>&gt;</span>Hello I'm some text<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"js-textareacutbtn"</span> <span class="attr">disable</span>&gt;</span>Cut Textarea<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们可以这么写js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cutTextareaBtn = <span class="built_in">document</span>.querySelector(<span class="string">'.js-textareacutbtn'</span>);</span><br><span class="line">cutTextareaBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cutTextarea = <span class="built_in">document</span>.querySelector(<span class="string">'.js-cuttextarea'</span>);</span><br><span class="line">    cutTextarea.select();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> successful = <span class="built_in">document</span>.execCommand(<span class="string">'cut'</span>);</span><br><span class="line">        <span class="keyword">var</span> msg = successful ? <span class="string">'successful'</span> : <span class="string">'unsuccessful'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Cutting text command was '</span> + msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Oops, unable to cut'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="queryCommandSupported和queryCommandEnabled"><a href="#queryCommandSupported和queryCommandEnabled" class="headerlink" title="queryCommandSupported和queryCommandEnabled"></a>queryCommandSupported和queryCommandEnabled</h4><p>在调用 document.execCommand() 之前你应该确认这个API是否被所在浏览器支持。这时候你可以用 document.queryCommandSupported() 方法来确认是否支持。在上面的例子中，我们可以在浏览器不支持时将按钮设置为disabled。具体代码如下：</p><p><code>copyEmailBtn.disabled = !document.queryCommandSupported(&#39;copy&#39;);</code></p><p>document.queryCommandSupported())和document.queryCommandEnabled())的区别是：前者检测浏览器是否支持剪切或拷贝，后者检测是否有选中的文本用于剪切或拷贝。这在让用户选中文本的情况（不用Selection API）下比较有用。如果没有选中的文本，你可以显示一个消息给用户，这样更加友好～</p><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><p>IE 10+、Chrome 43+和Opera 29+ 已经支持了这些命令。<br>Firefox虽然已经支持了这些命令，但是需要修改下首选项（<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand" rel="noopener" target="_blank">具体看这里</a>)。如果没有修改首选项，那么Firefox会抛出一个错误。<br>Safari目前不支持这些命令。</p><h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><p>直接用js代码调用 queryCommandSupported() 会一定会返回false，除非将其放在用户操作的回调函数中执行。这导致了你不能在浏览器不支持时禁用按钮。<br>在devtools中调用 queryCommandSupported() 一定会返回false。<br>目前剪切命令只在你用js选中文本时起作用。</p><h3 id="附：copy事件"><a href="#附：copy事件" class="headerlink" title="附：copy事件"></a>附：copy事件</h3><p>The copy event is fired when the user initiates a copy action through the browser UI (for example, using the CTRL/Cmd+C keyboard shortcut or selecting the “Copy” from the menu) and in response to an allowed <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand" rel="noopener" target="_blank">document.execCommand(‘copy’)</a> call.<br>A handler for this event can modify the provided ClipboardEvent.clipboardData object by calling setData(format, data):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'copy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.clipboardData.setData(<span class="string">'text/plain'</span>, <span class="string">'Hello, world!'</span>);</span><br><span class="line">    e.clipboardData.setData(<span class="string">'text/html'</span>, <span class="string">'&lt;b&gt;Hello, world!&lt;/b&gt;'</span>);</span><br><span class="line">    e.preventDefault(); <span class="comment">// We want our data, not data from any selection, to be written to the clipboard</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>A handler for this event cannot read the clipboard data using <code>clipboardData.getData()</code>.</p><h2 id="scrollHeight-clientHeight-scrollTop"><a href="#scrollHeight-clientHeight-scrollTop" class="headerlink" title="scrollHeight,clientHeight,scrollTop"></a><code>scrollHeight</code>,<code>clientHeight</code>,<code>scrollTop</code></h2><blockquote><p>来源：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollHeight" rel="noopener" target="_blank">MDN-Element.scrollHeight</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientHeight" rel="noopener" target="_blank">MDN-Element.clientHeight</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop" rel="noopener" target="_blank">MDN-Element.scrollTop</a></p></blockquote><h3 id="Element-scrollHeight"><a href="#Element-scrollHeight" class="headerlink" title="Element.scrollHeight"></a>Element.scrollHeight</h3><p><code>Element.scrollHeight</code> 是计量元素内容高度的<strong>只读属性</strong>，包括<code>overflow</code>样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，<code>scrollHeight</code>值与元素视图填充所有内容所需要的最小值<code>clientHeight</code>相同。包括元素的<code>padding</code>，但不包括元素的<code>margin</code>.</p><blockquote><p>属性将会对值四舍五入取整。如果需要小数值，使用Element.getBoundingClientRect().</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intElemScrollHeight = <span class="built_in">document</span>.getElementById(id_attribute_value).scrollHeight;</span><br></pre></td></tr></table></figure><p>intElemScrollHeight 存储着与元素scrollHeight像素值对应的一个整数。scrollHeight是一个只读属性。<br><img src="https://developer.mozilla.org/@api/deki/files/840/=ScrollHeight.png" alt="scrollHeight图解"></p><h4 id="判定元素是否滚动到底"><a href="#判定元素是否滚动到底" class="headerlink" title="判定元素是否滚动到底"></a>判定元素是否滚动到底</h4><p>如果元素滚动到底，下面等式返回true，没有则返回false.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.scrollHeight - element.scrollTop === element.clientHeight</span><br></pre></td></tr></table></figure></p><h4 id="scrollHeight-演示"><a href="#scrollHeight-演示" class="headerlink" title="scrollHeight 演示"></a>scrollHeight 演示</h4><p>监听onscroll事件，这个等式可以用来判定用户是否阅读过文本。（参考 <code>element.scrollTop</code> 和 <code>element.clientHeight</code>属性）。例如：<a href="http://jsbin.com/zeqohi/edit?html,css,js" rel="noopener" target="_blank">scrollHeight 演示</a></p><h3 id="Element-clientHeight"><a href="#Element-clientHeight" class="headerlink" title="Element.clientHeight"></a>Element.clientHeight</h3><p>返回元素内部的高度(单位像素)，包含<strong>内边距</strong>，但不包括水平滚动条、边框和外边距。</p><p><code>clientHeight</code> 可以通过 <code>CSS height</code> + <code>CSS padding</code> - <code>水平滚动条高度</code> (如果存在)来计算.</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>var h = element.clientHeight;</code><br>返回<strong>整数 h</strong>，表示 element 的 clientHeight（单位像素）。<br>clientHeight 是<code>只读</code>的.</p><h3 id="Element-scrollTop"><a href="#Element-scrollTop" class="headerlink" title="Element.scrollTop"></a>Element.scrollTop</h3><p>这个<code>Element.scrollTop</code> 属性可以设置或者获取一个元素距离他<strong>容器顶部</strong>的像素距离。一个元素的 <code>scrollTop</code> 是可以去计算出这个元素距离它容器顶部的可见高度。当一个元素的容器没有产生垂直方向的滚动条,那它的 scrollTop 的值默认为0.</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获得滚动的距离</span><br><span class="line">var  intElemScrollTop = someElement.scrollTop;</span><br></pre></td></tr></table></figure><p>运行下面的代码, 可以去给一个元素设置一个正确的像素整型数值，如果element的容器已经被滚动了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置滚动的距离</span><br><span class="line">element.scrollTop = intValue;</span><br></pre></td></tr></table></figure></p><p>scrollTop可以被设置任何的整数, 但以下情况会报错:</p><ul><li>如果一个元素不能被滚动 (e.g. 它没有溢出容器或者 这个元素是不可滚动的), scrollTop被设置为0.</li><li>设置scrollTop的值小于0，scrollTop 被设为0</li><li>如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.<br><img src="https://developer.mozilla.org/@api/deki/files/842/=ScrollTop.png" alt="scrollTop图解"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;reqeustAnimationFrame-RAF&quot;&gt;&lt;a href=&quot;#reqeustAnimationFrame-RAF&quot; class=&quot;headerlink&quot; title=&quot;reqeustAnimationFrame(RAF)&quot;&gt;&lt;/a&gt;&lt;code&gt;reqeustAnimationFrame(RAF)&lt;/code&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;来自：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;window.requestAnimationFrame()&lt;/strong&gt;这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。这个方法接受一个函数为参，该函数会在重绘前调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 如果想得到连贯的逐帧动画，函数中必须重新调用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你想做逐帧动画的时候，你应该用这个方法。这就要求你的动画函数执行会先于浏览器重绘动作。通常来说，被调用的频率是每秒60次，但是一般会遵循W3C标准规定的频率。如果是后台标签页面，重绘频率则会大大降低。&lt;/p&gt;
&lt;p&gt;回调函数只会被传入一个&lt;code&gt;DOMHighResTimeStamp&lt;/code&gt;参数，这个参数指示当前被 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 序列化的函数队列被触发的时间。因为很多个函数在这一帧被执行，所以每个函数都将被传入一个相同的时间戳，尽管经过了之前很多的计算工作。这个数值是一个小数，单位毫秒，精确度在 10 µs。&lt;br&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://note.chenteng.me/tags/JavaScript/"/>
    
      <category term="原生JS" scheme="http://note.chenteng.me/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET MVC摸索</title>
    <link href="http://note.chenteng.me/2016/05/09/ASP.NET%20MVC/"/>
    <id>http://note.chenteng.me/2016/05/09/ASP.NET MVC/</id>
    <published>2016-05-09T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC-ViewBag"><a href="#MVC-ViewBag" class="headerlink" title="MVC-ViewBag"></a>MVC-ViewBag</h2><p>一个控制器可以使用ViewBag对象来将数据或对象传递到视图模板中。ViewBag是一个<strong>动态对象</strong>，它提供了一种便利的，后期绑定的方法来<strong>将信息从控制器传递到视图</strong>中。你可以为它添加任何属性并赋上属性值。在未赋值之前该属性是不生效的，直到你赋值为止。例如：  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Welcome</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">int</span> numTimes = <span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ViewBag.Message = <span class="string">"Hello "</span> + name;</span><br><span class="line">            ViewBag.NumTimes = numTimes;</span><br><span class="line">            <span class="keyword">return</span> View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>ViewBag对象中已经包含了数据，它将被自动传递给视图。</p><a id="more"></a><h2 id="MVC-控制器向View传值的三种方法"><a href="#MVC-控制器向View传值的三种方法" class="headerlink" title="MVC 控制器向View传值的三种方法"></a>MVC 控制器向View传值的三种方法</h2><ol><li><p><strong>提供视图模型对象</strong>  </p><ul><li><p>你能把一个对象作为View方法的参数传递给视图.  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewResult <span class="title">Index</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">DateTime date = DateTime.Now;  </span><br><span class="line"><span class="keyword">return</span> View(date);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们在视图中使用Razor的Model关键字来访问这个对象   </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@&#123;  </span><br><span class="line">ViewBag.Title = <span class="string">"Index"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;h2&gt;Index&lt;/h2&gt;  </span><br><span class="line">The day <span class="keyword">is</span>: @(((DateTime)Model).DayOfWeek)   </span><br><span class="line">``` </span><br><span class="line">或者是  </span><br><span class="line">```cs</span><br><span class="line">@model DateTime    </span><br><span class="line">@&#123;  </span><br><span class="line">ViewBag.Title = <span class="string">"Index"</span>;  </span><br><span class="line">&#125;    </span><br><span class="line">&lt;h2&gt;Index&lt;/h2&gt;  </span><br><span class="line">The day <span class="keyword">is</span>: @Model.DayOfWeek </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> **使用ViewBag(视图包)传递数据**  </span><br><span class="line">* View  Bag 允许在一个动态的对象上定义任意属性,并在视图中访问它.这个动态的对象可以通过Controller.ViewBag属性访问它.  </span><br><span class="line">```cs</span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResult <span class="title">Index</span>(<span class="params"></span>)    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ViewBag.Message = <span class="string">"Hello"</span>;    </span><br><span class="line">    ViewBag.Date = DateTime.Now;    </span><br><span class="line">    <span class="keyword">return</span> View();    </span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line">@&#123;</span><br><span class="line">ViewBag.Title = <span class="string">"Index"</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">&lt;h&gt;Index&lt;/h&gt;    </span><br><span class="line">The day <span class="keyword">is</span>: @ViewBag.Date.DayOfWeek    </span><br><span class="line">&lt;p /&gt;  </span><br><span class="line">The message <span class="keyword">is</span>: @ViewBag.Message</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用View Data传递数据</strong>  </p><ul><li>在MVC3.0之前,主要是通过这种方式传递数据,它是通过用 ViewDataDictionary类实现的,而不是动态的对象.ViewDataDictionary类是类似标准”键/值”集合,并通过Controller类的ViewData属性进行访问的.这个方法,在视图中需要对对象进行转换.<br><em>控制器中:</em> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewResult <span class="title">Index</span>(<span class="params"></span>)    </span></span><br><span class="line"><span class="function"> </span>&#123;    </span><br><span class="line">    ViewData[<span class="string">"Message"</span>] = <span class="string">"Hello"</span>;    </span><br><span class="line">    ViewData[<span class="string">"Date"</span>] = DateTime.Now;    </span><br><span class="line">    <span class="keyword">return</span> View();    </span><br><span class="line"> &#125;    </span><br><span class="line"></span><br><span class="line">   ```  </span><br><span class="line">*视图中:*  </span><br><span class="line"></span><br><span class="line">```cs</span><br><span class="line"> @&#123;   </span><br><span class="line"> ViewBag.Title = <span class="string">"Index"</span>;  </span><br><span class="line"> &#125;    </span><br><span class="line"> &lt;h2&gt;Index&lt;/h2&gt;    </span><br><span class="line"> The day <span class="keyword">is</span>: @(((DateTime)ViewData[<span class="string">"Date"</span>]).DayOfWeek)    </span><br><span class="line"> &lt;p /&gt;    </span><br><span class="line"> The message <span class="keyword">is</span>: @ViewData[<span class="string">"Message"</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="ASP-NET-MVC中form提交和控制器接受form提交过来的数据"><a href="#ASP-NET-MVC中form提交和控制器接受form提交过来的数据" class="headerlink" title="ASP.NET MVC中form提交和控制器接受form提交过来的数据"></a>ASP.NET MVC中form提交和控制器接受form提交过来的数据</h2><ol><li><strong>cshtml页面form提交</strong><br><img src="http://i.imgur.com/GIv73hk.png" alt="">  </li><li><strong>控制器处理表单提交数据4种方式</strong>  </li></ol><p>方法1:使用传统的Request请求取值<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">AddNews</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">string</span> a=Request[<span class="string">"text1"</span>];</span><br><span class="line"><span class="keyword">string</span> b=Request[<span class="string">"text2"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法2:Action参数名与表单元素name值一一对应<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">AddNews</span>(<span class="params"><span class="keyword">string</span> text1,<span class="keyword">string</span> text2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> a=text1;</span><br><span class="line">    <span class="keyword">string</span> b=text2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法3:从MVC封装的FormCollection容器中读取<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">AddNews</span>(<span class="params">FormCollection form</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> a=form[<span class="string">"text1"</span>];</span><br><span class="line">    <span class="keyword">string</span> b=form[<span class="string">"text2"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法4:使用实体作为Action参数传入，前提是提交的表单元素名称与实体属性名称一一对应<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">AddNews</span>(<span class="params">userModel user</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> a=user.text1;</span><br><span class="line">    <span class="keyword">string</span> b=user.text2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ASP-NET-MVC-中的ViewData与ViewBag"><a href="#ASP-NET-MVC-中的ViewData与ViewBag" class="headerlink" title="ASP.NET MVC 中的ViewData与ViewBag"></a>ASP.NET MVC 中的ViewData与ViewBag</h2><blockquote><p>Asp.net MVC默认使用 Web Form来作为View，新建的aspx页面均是继承于ViewPage。而ViewData和ViewBag都是ViewPage的属性。ViewPage.ViewData表示获取或设置一个字典，其中包含在控制器和视图时间传递的数据，也就是说ViewPage.ViewData是控制器Controller和视图View之间沟通传递数据的桥梁。而ViewPage.ViewBag则表示获取一个视图包。</p></blockquote><table><thead><tr><th>i</th><th>类型和作用</th><th>引入时间</th><th>版本</th><th>查询速度</th><th>是否需要类型转换</th><th>可读性</th></tr></thead><tbody><tr><td>ViewData</td><td>字典类型（Key和Value的合）是 Controller和View之间传递数据的桥梁</td><td>ASP.NETMVC 1.0引入</td><td>基于.Net Framework 3.5</td><td>ViewData查询速度比ViewBag快</td><td>在ViewPage中查询数据时需要进行类型转换</td><td>可读性相对要差点</td></tr><tr><td>ViewBag</td><td>dynamic类型</td><td>ASP.NET MVC 3.0引入</td><td>基于.Net Framework 4.0</td><td>查询速度比ViewData慢</td><td>在ViewPage中查询数据时不需要进行类型转换</td><td>可读性更好</td></tr></tbody></table><h2 id="MVC3中PartialView-与View-的区别"><a href="#MVC3中PartialView-与View-的区别" class="headerlink" title="MVC3中PartialView()与View()的区别"></a>MVC3中PartialView()与View()的区别</h2><p>当我们使用razor作为页面引擎时，它的视图文件扩展名为cshtml或者vbshtml，而之前作为分部视图的ascx文件，进行razor之后，也是cshtml，这与非razor引擎有些不同，在这方面，官方并没有显式把分部视图与标准视图分开，有时，我们在开发时，可能会出现一些混乱了，今天主要来说一下，如何正确的使用分部视图！</p><p><strong>分部视图</strong>在action中返回一定要用<code>PartialView()</code>，而不要偷懒使用<code>View()</code>，因为，如果你使用View()渲染视图，系统会认为你是一个标准视图，会为你加个默认的母板页（Layout)，除非你显式的设置了Layout这个属性。</p><p><img src="http://i.imgur.com/66PeL4y.png" alt="layout=null"></p><p>之前的程序代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  　　　 <span class="function"><span class="keyword">public</span> ActionResult <span class="title">PartialLogon</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">2         </span>&#123;</span><br><span class="line"><span class="number">3</span>             <span class="keyword">return</span> View();<span class="comment">//会认识它的标准视图，所以会加上默认的Layout</span></span><br><span class="line"><span class="number">4</span>         &#125;</span><br></pre></td></tr></table></figure><p>当返回视图后，你的分部视图会被加上默认的母板页，这不是我们希望看到的，当然有些同学会不先麻烦的在页面上显式的加上Layout=null</p><p>事实上，如果你正确的返回分部视图，这行当然是不用加的。</p><p>正确的写法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">PartialLogon</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> PartialView();<span class="comment">//会将页面的Layout自动设为null</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我想这后我们把这两个东西换个名称：</p><ul><li>PartialView()=&gt;渲染视图=&gt;不带Layout</li><li>View()=&gt;渲染分部视图=&gt;自动加上Layout</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVC-ViewBag&quot;&gt;&lt;a href=&quot;#MVC-ViewBag&quot; class=&quot;headerlink&quot; title=&quot;MVC-ViewBag&quot;&gt;&lt;/a&gt;MVC-ViewBag&lt;/h2&gt;&lt;p&gt;一个控制器可以使用ViewBag对象来将数据或对象传递到视图模板中。ViewBag是一个&lt;strong&gt;动态对象&lt;/strong&gt;，它提供了一种便利的，后期绑定的方法来&lt;strong&gt;将信息从控制器传递到视图&lt;/strong&gt;中。你可以为它添加任何属性并赋上属性值。在未赋值之前该属性是不生效的，直到你赋值为止。例如：  &lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ActionResult &lt;span class=&quot;title&quot;&gt;Welcome&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; name, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numTimes = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;        &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ViewBag.Message = &lt;span class=&quot;string&quot;&gt;&quot;Hello &quot;&lt;/span&gt; + name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ViewBag.NumTimes = numTimes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; View();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ViewBag对象中已经包含了数据，它将被自动传递给视图。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记整理" scheme="http://note.chenteng.me/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="ASP.NET MVC" scheme="http://note.chenteng.me/tags/ASP-NET-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://note.chenteng.me/2016/05/01/hello-world/"/>
    <id>http://note.chenteng.me/2016/05/01/hello-world/</id>
    <published>2016-05-01T00:00:00.000Z</published>
    <updated>2017-12-04T16:24:29.199Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="感悟生活" scheme="http://note.chenteng.me/categories/%E6%84%9F%E6%82%9F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://note.chenteng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
